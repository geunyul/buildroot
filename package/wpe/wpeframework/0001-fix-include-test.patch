diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8b306bc..b4c5fda 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -81,4 +81,8 @@ if(APPLE)
     set(CMAKE_INSTALL_RPATH_USE_LINK_PATH TRUE)
 endif()
 
-add_subdirectory(Source)
\ No newline at end of file
+add_subdirectory(Source)
+
+if(BUILD_TESTS)
+    add_subdirectory(Tests)
+endif()
diff --git a/Source/CMakeLists.txt b/Source/CMakeLists.txt
index 8e82623..af6580b 100644
--- a/Source/CMakeLists.txt
+++ b/Source/CMakeLists.txt
@@ -66,10 +66,6 @@ option(PROCESSCONTAINERS
         "Include containerization in the build." OFF)
 option(TEST_APPS
         "Include test applications." OFF)
-option(UNIT_TESTS
-        "Include unit tests (new gtest based)." OFF)
-option(TEST_MEASUREMENTS
-        "Include code coverage measurments." OFF)
 option(STUB_HARDWARE
         "Use hardware stubs for unittests)." OFF)
 option(BUILD_TYPE
@@ -102,9 +98,10 @@ string(REPLACE " " ";" EXTERN_EVENT_LIST "${EXTERN_EVENTS}")
 message("-- Assuming external events: ${EXTERN_EVENT_LIST}")
 
 #FIXME: We shouldn't touch cflags...
-if(TEST_MEASUREMENTS)
-    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fprofile-arcs -ftest-coverage")
-    set(CMAKE_EXE_LINKER_FLAGS -lgcov)
+if(BUILD_TESTS)
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} --coverage -fkeep-inline-functions -fkeep-static-functions")
+    set(CMAKE_SHARED_LIBRARY_LINK_CXX_FLAGS "-lsupc++")
+    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -pthread")
 endif ()
 
 if(CORE)
diff --git a/Source/core/Sync.cpp b/Source/core/Sync.cpp
index 339191f..e221b56 100644
--- a/Source/core/Sync.cpp
+++ b/Source/core/Sync.cpp
@@ -54,6 +54,15 @@
 //----------------------------------------------------------------------------
 //----------------------------------------------------------------------------
 
+#if BUILD_TESTS
+// TODO: What is going on here??
+//  https://github.com/google/googletest/issues/2328
+#include <cxxabi.h>
+__gnu_cxx::recursive_init_error::~recursive_init_error()
+{
+}
+#endif
+
 namespace WPEFramework {
 namespace Core {
 
diff --git a/Source/core/core.h b/Source/core/core.h
index 1c950c6..aab9588 100644
--- a/Source/core/core.h
+++ b/Source/core/core.h
@@ -72,6 +72,7 @@
 #include "Queue.h"
 #include "Range.h"
 #include "ReadWriteLock.h"
+#include "Rectangle.h"
 #include "ResourceMonitor.h"
 #include "SerialPort.h"
 #include "Serialization.h"
diff --git a/Tests/CMakeLists.txt b/Tests/CMakeLists.txt
index 2e1aff2..08bb518 100644
--- a/Tests/CMakeLists.txt
+++ b/Tests/CMakeLists.txt
@@ -17,7 +17,9 @@
 
 find_package(GTest REQUIRED)
 
-set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fprofile-arcs -ftest-coverage --coverage -fno-inline -fno-inline-small-functions -fno-default-inline")
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} --coverage -fkeep-static-functions -fkeep-inline-functions")
+set(CMAKE_SHARED_LIBRARY_LINK_CXX_FLAGS "-lsupc++")
+set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -pthread")
 
 include_directories(${GTEST_INCLUDE_DIR})
 include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../Source)
@@ -28,5 +30,5 @@ enable_testing()
 
 add_subdirectory(core)
 add_subdirectory(tests)
-add_subdirectory(cryptography)
+#add_subdirectory(cryptography)
 
diff --git a/Tests/core/CMakeLists.txt b/Tests/core/CMakeLists.txt
index 8b7e8d0..deaab18 100644
--- a/Tests/core/CMakeLists.txt
+++ b/Tests/core/CMakeLists.txt
@@ -19,11 +19,67 @@ set(TEST_RUNNER_NAME "WPEFramework_test_core")
 
 add_executable(${TEST_RUNNER_NAME}
    ../IPTestAdministrator.cpp
-   test_ipcclient.cpp
-   test_rpc.cpp
-   test_jsonparser.cpp
+   test_cyclicbuffer.cpp
+   test_databuffer.cpp
+   test_dataelementfile.cpp
+   test_dataelement.cpp
+   test_doorbell.cpp
+   test_event.cpp
    test_hex2strserialization.cpp
+   test_enumerate.cpp
+   test_filesystem.cpp
+   test_frametype.cpp
+   test_ipc.cpp
+   test_iso639.cpp
+   test_iterator.cpp
+   test_json.cpp
+   test_jsonparser.cpp
+   test_keyvalue.cpp
+   test_library.cpp
+   test_lockablecontainer.cpp
+   test_logging.cpp
+   test_measurementtype.cpp
+   test_messageException.cpp
+   #test_networkinfo.cpp
+   test_nodeid.cpp
+   test_numbertype.cpp
+   test_optional.cpp
+   test_parser.cpp
+   test_portability.cpp
+   test_processinfo.cpp
+   test_queue.cpp
+   test_rangetype.cpp
+   test_readwritelock.cpp
+   test_rectangle.cpp
+   test_rpc.cpp
+   test_semaphore.cpp
    test_sharedbuffer.cpp
+   test_singleton.cpp
+   test_socketstreamjson.cpp
+   test_socketstreamtext.cpp
+   test_statetrigger.cpp
+   test_stopwatch.cpp
+   test_synchronize.cpp
+   test_synchronous.cpp
+   test_systeminfo.cpp
+   test_textfragment.cpp
+   test_textreader.cpp
+   test_thread.cpp
+   test_time.cpp
+   test_timer.cpp
+   test_tracing.cpp
+   test_tristate.cpp
+   test_valuerecorder.cpp
+   test_weblinkjson.cpp
+   test_weblinktext.cpp
+   test_websocketjson.cpp
+   test_websockettext.cpp
+   test_workerpool.cpp
+   test_xgetopt.cpp
+)
+
+target_compile_definitions(${TEST_RUNNER_NAME}
+   PRIVATE BUILD_DIR=\"${CMAKE_CURRENT_BINARY_DIR}\"
 )
 
 target_link_libraries(${TEST_RUNNER_NAME} 
diff --git b/Tests/core/test_cyclicbuffer.cpp b/Tests/core/test_cyclicbuffer.cpp
new file mode 100644
index 0000000..b01b438
--- /dev/null
+++ b/Tests/core/test_cyclicbuffer.cpp
@@ -0,0 +1,286 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+#include <thread>
+#include <condition_variable>
+#include <mutex>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+namespace Tests {
+
+    class ThreadClass : public Thread {
+    public:
+        ThreadClass() = delete;
+        ThreadClass(const ThreadClass&) = delete;
+        ThreadClass& operator=(const ThreadClass&) = delete;
+
+        ThreadClass(CyclicBuffer& cyclicBuffer, volatile bool& done, std::mutex& mutex, std::condition_variable& cv)
+            : Thread(Thread::DefaultStackSize(), _T("Test"))
+            , _cyclicBuffer(cyclicBuffer)
+            , _done(done)
+            , _mutex(mutex)
+            , _cv(cv)
+        {
+        }
+
+        virtual ~ThreadClass()
+        {
+        }
+
+        virtual uint32_t Worker() override
+        {
+            while (IsRunning() && (!_done)) {
+                _cyclicBuffer.Alert();
+                std::unique_lock<std::mutex> lk(_mutex);
+                _done = true;
+                _cv.notify_one();
+            }
+            return (infinite);
+        }
+
+    private:
+        CyclicBuffer& _cyclicBuffer;
+        volatile bool& _done;
+        std::mutex& _mutex;
+        std::condition_variable& _cv;
+    };
+
+    TEST(Core_CyclicBuffer, WithoutOverwrite)
+    {
+        std::string bufferName {"cyclicbuffer02"};
+        auto lambdaFunc = [bufferName](IPTestAdministrator & testAdmin) {
+            uint32_t result;
+            string data;
+            uint32_t cyclicBufferSize = 10;
+            uint8_t loadBuffer[cyclicBufferSize + 1];
+
+            CyclicBuffer buffer(bufferName.c_str(), cyclicBufferSize, false);
+
+            testAdmin.Sync("setup server");
+
+            testAdmin.Sync("setup client");
+
+            EXPECT_EQ(buffer.Read(loadBuffer, buffer.Used()), 0u);
+
+            data = "abcdefghi";
+            result = buffer.Write(reinterpret_cast<const uint8_t*>(data.c_str()), data.size());
+            EXPECT_EQ(result, data.size());
+
+            testAdmin.Sync("server wrote");
+
+            testAdmin.Sync("client read");
+
+            testAdmin.Sync("client wrote");
+
+            result = buffer.Peek(loadBuffer, buffer.Used());
+            loadBuffer[result] = '\0';
+            EXPECT_EQ(result, 5u);
+            EXPECT_STREQ((char*)loadBuffer, "efghi");
+
+            testAdmin.Sync("server peek");
+
+            result = buffer.Read(loadBuffer, buffer.Used());
+            loadBuffer[result] = '\0';
+            EXPECT_EQ(result, 5u);
+            EXPECT_STREQ((char*)loadBuffer, "efghi");
+
+            testAdmin.Sync("server read");
+        };
+
+        static std::function<void (IPTestAdministrator&)> lambdaVar = lambdaFunc;
+
+        IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin ) { lambdaVar(testAdmin); };
+
+        // This side (tested) acts as client
+        IPTestAdministrator testAdmin(otherSide);
+        {
+            testAdmin.Sync("setup server");
+
+            uint32_t result;
+            string data;
+            uint32_t cyclicBufferSize = 10;
+            uint8_t loadBuffer[cyclicBufferSize + 1];
+
+            CyclicBuffer buffer(bufferName.c_str(), cyclicBufferSize, false);
+
+            testAdmin.Sync("setup client");
+
+            testAdmin.Sync("server wrote");
+
+            result = buffer.Read(loadBuffer, 4);
+            loadBuffer[result] = '\0';
+            EXPECT_STREQ((char*)loadBuffer, "abcd");
+
+            testAdmin.Sync("client read");
+
+            data = "klmnopq";
+            result = buffer.Reserve(data.size());
+            EXPECT_EQ(result, ERROR_INVALID_INPUT_LENGTH);
+            result = buffer.Write(reinterpret_cast<const uint8_t*>(data.c_str()), data.size());
+            EXPECT_EQ(result, 0u);
+
+            testAdmin.Sync("client wrote");
+
+            testAdmin.Sync("server peek");
+
+            testAdmin.Sync("server read");
+        }
+        Singleton::Dispose();
+    }
+
+    TEST(Core_CyclicBuffer, WithOverwrite)
+    {
+        std::string bufferName {"cyclicbuffer03"};
+
+        auto lambdaFunc = [bufferName](IPTestAdministrator & testAdmin) {
+            uint32_t result;
+            string data;
+            uint32_t cyclicBufferSize = 10;
+            uint8_t loadBuffer[cyclicBufferSize + 1];
+
+            CyclicBuffer buffer(bufferName.c_str(), cyclicBufferSize, true);
+
+            testAdmin.Sync("setup server");
+
+            testAdmin.Sync("setup client");
+
+            EXPECT_EQ(buffer.Read(loadBuffer, buffer.Used()), 0u);
+
+            data = "abcdefghi";
+            result = buffer.Write(reinterpret_cast<const uint8_t*>(data.c_str()), data.size());
+            EXPECT_EQ(result, data.size());
+
+            testAdmin.Sync("server wrote");
+
+            testAdmin.Sync("client read");
+
+            testAdmin.Sync("client wrote");
+
+            result = buffer.Peek(loadBuffer, buffer.Used());
+            loadBuffer[result] = '\0';
+            EXPECT_EQ(result, 9u);
+            EXPECT_STREQ((char*)loadBuffer, "ijklmnopq");
+
+            testAdmin.Sync("server peek");
+
+            result = buffer.Read(loadBuffer, buffer.Used());
+            loadBuffer[result] = '\0';
+            EXPECT_EQ(result, 9u);
+            EXPECT_STREQ((char*)loadBuffer, "ijklmnopq");
+
+            buffer.Alert();
+            buffer.Flush();
+
+            EXPECT_FALSE(buffer.Overwritten());
+            EXPECT_FALSE(buffer.IsLocked());
+
+            EXPECT_EQ(buffer.ErrorCode(), 2u);
+            EXPECT_EQ(buffer.LockPid(), 0u);
+            EXPECT_EQ(buffer.Free(), 10u);
+
+            EXPECT_STREQ(buffer.Name().c_str(), bufferName.c_str());
+            EXPECT_STREQ(buffer.Storage().Name().c_str(), bufferName.c_str());
+
+            EXPECT_TRUE(buffer.IsOverwrite());
+            EXPECT_TRUE(buffer.IsValid());
+
+            testAdmin.Sync("server read");
+        };
+
+        static std::function<void (IPTestAdministrator&)> lambdaVar = lambdaFunc;
+
+        IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin ) { lambdaVar(testAdmin); };
+
+        // This side (tested) acts as client
+        IPTestAdministrator testAdmin(otherSide);
+        {
+            testAdmin.Sync("setup server");
+
+            uint32_t result;
+            string data;
+            uint32_t cyclicBufferSize = 10;
+            uint8_t loadBuffer[cyclicBufferSize + 1];
+
+            CyclicBuffer buffer(bufferName.c_str(), cyclicBufferSize, true);
+
+            testAdmin.Sync("setup client");
+
+            testAdmin.Sync("server wrote");
+
+            result = buffer.Read(loadBuffer, 4);
+            loadBuffer[result] = '\0';
+            EXPECT_STREQ((char*)loadBuffer, "abcd");
+
+            testAdmin.Sync("client read");
+
+            data = "j";
+            result = buffer.Reserve(8);
+            result = buffer.Write(reinterpret_cast<const uint8_t*>(data.c_str()), data.size());
+            EXPECT_EQ(result, data.size());
+            data = "klmnopq";
+            result = buffer.Write(reinterpret_cast<const uint8_t*>(data.c_str()), data.size());
+            EXPECT_EQ(result, data.size());
+
+            testAdmin.Sync("client wrote");
+
+            testAdmin.Sync("server peek");
+
+            testAdmin.Sync("server read");
+        }
+        Singleton::Dispose();
+    }
+
+    TEST(Core_CyclicBuffer, lock)
+    {
+        char bufferName[] = "cyclicbuffer04";
+        uint32_t cyclicBufferSize = 10;
+
+        CyclicBuffer buffer(bufferName, cyclicBufferSize, true);
+        buffer.Lock(false, 500);
+        buffer.Unlock();
+        buffer.Lock(true, 1000);
+    }
+
+    TEST(Core_CyclicBuffer, lock_unlock)
+    {
+        char bufferName[] = "cyclicbuffer01";
+        uint32_t bufferSize = 10;
+
+        CyclicBuffer buffer(bufferName, bufferSize, true);
+
+        volatile bool done = false;
+        std::mutex mutex;
+        std::condition_variable cv;
+
+        ThreadClass object(buffer, done, mutex, cv);
+        object.Run();
+        buffer.Lock(true, infinite);
+        std::unique_lock<std::mutex> lk(mutex);
+        while (!done) {
+            cv.wait(lk);
+        }
+        object.Stop();
+    }
+} // Tests
diff --git b/Tests/core/test_databuffer.cpp b/Tests/core/test_databuffer.cpp
new file mode 100644
index 0000000..a9ddf23
--- /dev/null
+++ b/Tests/core/test_databuffer.cpp
@@ -0,0 +1,67 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+
+TEST(Core_DataBuffer, simpleSet)
+{
+    uint32_t bufferSize = 10;    
+    uint32_t size;
+    uint8_t* received = new uint8_t[bufferSize + 1];
+    memset(received, 0, (bufferSize + 1));
+
+    Core::CyclicDataBuffer<Core::ScopedStorage<10>> buffer;
+    EXPECT_TRUE(buffer.IsEmpty());
+    EXPECT_EQ(buffer.Filled(), 0u);
+    EXPECT_EQ(buffer.Free(), bufferSize);
+
+    string data = "abcdefghi";
+    size = buffer.Write((uint8_t*)data.c_str(), data.size());
+    EXPECT_EQ(buffer.Filled(), 9u);
+    EXPECT_EQ(buffer.Free(), 1u);
+    EXPECT_EQ(size, data.size());
+
+    size = buffer.Read(received, 4);
+    received[size] = '\0';
+    EXPECT_STREQ((char*)received, "abcd");
+    EXPECT_EQ(buffer.Filled(), 5u);
+    EXPECT_EQ(buffer.Free(), 5u);
+    EXPECT_EQ(size, 4u);
+
+    data = "jklmnopq";
+    size = buffer.Write((uint8_t*)data.c_str(), data.size());
+    EXPECT_EQ(buffer.Filled(), 9u);
+    EXPECT_EQ(buffer.Free(), 1u);
+    EXPECT_EQ(size, data.size());
+
+    size = buffer.Read((uint8_t*)received, buffer.Filled());
+    received[size] = '\0';
+    EXPECT_STREQ((char*)received, "ijklmnopq");
+    EXPECT_EQ(buffer.Filled(), 0u);
+    EXPECT_EQ(buffer.Free(), 10u);
+    EXPECT_EQ(size, 9u);
+
+    delete[] received;
+    Core::Singleton::Dispose();
+}
diff --git b/Tests/core/test_dataelement.cpp b/Tests/core/test_dataelement.cpp
new file mode 100644
index 0000000..ab3b1c7
--- /dev/null
+++ b/Tests/core/test_dataelement.cpp
@@ -0,0 +1,115 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/DataElement.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+TEST(test_data, simple_data)
+{
+    const uint8_t arr[] = {10,20,30,40,50,60,70,80,90,100};
+    const uint16_t len = 5;
+    const uint16_t off = 0;
+    DataStore obj1;
+    obj1.Copy(arr,len,off);
+    uint32_t size = 1024;
+    EXPECT_EQ(obj1.Size(),size);
+    obj1.Size(1025);
+    EXPECT_EQ(*obj1.Buffer(),10);
+
+    uint8_t arr1[] = {10,20,30,40,50,60,70,80,90,100};
+    const uint64_t s = 10;
+    DataElement obj_sample;
+    DataElement obj2(s,arr1);
+    DataElement obj_operator = obj2;
+    uint32_t crc = 4134036294;
+    EXPECT_EQ(obj2.CRC32(0,10),crc);
+    EXPECT_TRUE(obj2.Copy(obj2,0));
+
+    uint64_t alloc_size = 10;
+    EXPECT_EQ(obj2.AllocatedSize(), alloc_size);
+    EXPECT_TRUE(obj2.Size(sizeof(arr)));
+    EXPECT_TRUE(obj2.IsValid());
+    EXPECT_EQ(*obj2.Buffer(),10);
+
+    uint8_t arr2[] = {10,20,30,40,50};
+    const uint8_t infom = 10;
+    uint64_t SearchNumber = 10;
+    EXPECT_EQ((obj2.SearchNumber<uint8_t, Core::ENDIAN_BIG>(2,infom)),SearchNumber);
+    obj2.SetNumber<uint64_t, Core::ENDIAN_BIG>(2,10);
+    uint64_t GetNumber = 10;
+    EXPECT_EQ((obj2.GetNumber<uint64_t, Core::ENDIAN_BIG>(2)),GetNumber);
+
+    obj2.Search(2,arr2,5);
+    obj2.SetBitNumber<uint64_t>(2,5,8,10);
+    uint64_t GetBitNumber = 10;
+    EXPECT_EQ(obj2.GetBitNumber<uint64_t>(2,5,8),GetBitNumber);
+
+    const uint8_t val= 32;
+    const uint64_t offset= 0;
+    obj2.Set(val,offset);
+    obj2.Align<uint8_t>();
+
+    DataElement obj(obj2);
+    DataElement obj3 = obj;
+    DataElement obj4(obj2,0,0);
+
+    uint32_t ob_size = 10;
+    EXPECT_EQ(obj3.Size(),ob_size);
+    EXPECT_FALSE(obj3.Expand(0,0));
+    EXPECT_TRUE(obj3.Shrink(0,0));
+    EXPECT_FALSE(obj3.Copy(obj2));
+}
+
+TEST(test_linkeddata, simple_linkeddata)
+{
+    uint8_t arr[] = {10,20,30,40,50,60,70,80,90,100};
+    uint8_t arr1[] ={};
+    const uint64_t offset= 0;
+    DataElement objt1(10,arr);
+    LinkedDataElement ob1;
+    LinkedDataElement ob2(objt1);
+    LinkedDataElement ob3(ob2);
+    ob3.Enclosed(&ob2);
+    ob3.SetBuffer(2,9,arr);
+    ob3.GetBuffer(2,9,arr1);
+    LinkedDataElement ob4;
+    ob4 = ob2;
+    EXPECT_EQ(ob4.Copy(offset,ob2), unsigned(10));
+    EXPECT_EQ(ob2.Copy(offset,ob3), unsigned(10));
+
+    ob1.Enclosed();
+    EXPECT_EQ(ob2.LinkedSize(), unsigned(10));
+    EXPECT_EQ(ob2.LinkedElements(),unsigned(1));
+}
+
+TEST(test_dataParser, simple_dataParser)
+{
+    uint8_t arr[] = {10,20,30,40,50};
+    DataElement object1(10,arr);
+    DataElementParser parser1(object1,0);
+    uint64_t size = -10;
+    EXPECT_TRUE(parser1.IsValid());
+    EXPECT_EQ(parser1.Size(),size);
+    parser1.SkipBytes(2);
+}
diff --git b/Tests/core/test_dataelementfile.cpp b/Tests/core/test_dataelementfile.cpp
new file mode 100644
index 0000000..0d5754f
--- /dev/null
+++ b/Tests/core/test_dataelementfile.cpp
@@ -0,0 +1,71 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+class DataFile: public Core::DataElementFile
+{
+public:
+    DataFile() = delete;
+
+    DataFile(File& file)
+        : DataElementFile(file)
+    {
+    }
+
+    DataFile(string fileName, uint32_t type, uint32_t size)
+        :DataElementFile(fileName, type, size)
+    {
+    }
+
+    void MemoryMap()
+    {
+        Reallocation(54);
+        ReopenMemoryMappedFile();
+    }
+};
+
+TEST(test_datafile, simple_test)
+{
+    char buffer[100];
+    const string fileName = "dataFile.txt";
+    string message = ">echo 'DataElement file checking......'";
+    snprintf(buffer,(message.size() + fileName.size()+1), "%s%s",message.c_str(),fileName.c_str());
+    File file(fileName);
+    File fileSample(file);
+    DataFile obj1(fileSample);
+    DataFile object(fileName, 1, 10);
+    EXPECT_EQ(obj1.ErrorCode(),unsigned(2));
+    DataFile obj2(fileName, 1, 50);
+    obj1.Sync();
+    obj2.MemoryMap();
+
+    const string& name = obj1.Name();
+    EXPECT_EQ(name.c_str(), fileName);
+    EXPECT_FALSE(obj2.IsValid());
+    obj1.Storage();
+    obj1.ReloadFileInfo();
+    obj1.MemoryMap();
+}
diff --git b/Tests/core/test_doorbell.cpp b/Tests/core/test_doorbell.cpp
new file mode 100644
index 0000000..5163a64
--- /dev/null
+++ b/Tests/core/test_doorbell.cpp
@@ -0,0 +1,41 @@
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+namespace WPEFramework {
+namespace Tests {
+
+    TEST(Core_DoorBell, simpleSet)
+    {
+        std::string fileName {"/tmp/doorbell01"};
+        auto lambdaFunc = [fileName] (IPTestAdministrator & testAdmin) {
+            Core::DoorBell doorBell(fileName.c_str());
+            if (doorBell.Wait(Core::infinite) == Core::ERROR_NONE) {
+                doorBell.Acknowledge();
+                testAdmin.Sync("First ring");
+            }
+
+            if (doorBell.Wait(Core::infinite) == Core::ERROR_NONE) {
+                doorBell.Acknowledge();
+                testAdmin.Sync("Second ring");
+            }
+            doorBell.Relinquish();
+        };
+
+        static std::function<void (IPTestAdministrator&)> lambdaVar = lambdaFunc;
+
+        IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin ) { lambdaVar(testAdmin); };
+
+        IPTestAdministrator testAdmin(otherSide);
+        {
+            Core::DoorBell doorBell(fileName.c_str());
+            ::SleepMs(10);
+            doorBell.Ring();
+            testAdmin.Sync("First ring");
+            doorBell.Ring();
+            testAdmin.Sync("Second ring");
+        }
+    }
+} // Tests
+} // WPEFramework
diff --git b/Tests/core/test_enumerate.cpp b/Tests/core/test_enumerate.cpp
new file mode 100644
index 0000000..a14e70e
--- /dev/null
+++ b/Tests/core/test_enumerate.cpp
@@ -0,0 +1,151 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+namespace WPEFramework {
+namespace Tests {
+
+    enum class TestEnum {
+        ONE,
+        TWO,
+        THREE
+    };    
+
+    TEST(Core_Enumerate, CheckEntries)
+    {
+        Core::EnumerateType<TestEnum> testEnum;
+        EXPECT_FALSE(testEnum.IsSet());
+        for (int i = 0; i < 3; i++) {
+            EXPECT_EQ(testEnum.Entry(i)->value, (i == 0 ? TestEnum::ONE : (i == 1 ? TestEnum::TWO : TestEnum::THREE)));
+            EXPECT_STREQ(testEnum.Entry(i)->name, (i == 0 ? "ONE" : (i == 1 ? "TWO" : "THREE")));
+        }
+    }
+
+    TEST(Core_Enumerate, Assignment)
+    {
+        Core::EnumerateType<TestEnum> testEnum;
+        testEnum.Assignment(true, "three");
+        EXPECT_FALSE(testEnum.IsSet());
+
+        testEnum.Assignment(true, "THREE");
+        EXPECT_TRUE(testEnum.IsSet());
+        EXPECT_EQ(testEnum.Value(), TestEnum::THREE);
+        EXPECT_STREQ(testEnum.Data(), "THREE");
+
+        testEnum.Assignment(false, "three");
+        EXPECT_EQ(testEnum.Value(), TestEnum::THREE);
+        EXPECT_STREQ(testEnum.Data(), "THREE");
+
+        testEnum.Assignment(false, "four");
+        EXPECT_FALSE(testEnum.IsSet());
+
+        testEnum.Clear();
+        EXPECT_FALSE(testEnum.IsSet());
+
+        Core::EnumerateType<TestEnum> testEnum1;
+        testEnum.Assignment(true, "three");
+
+        EXPECT_FALSE(testEnum != testEnum1);
+        EXPECT_TRUE(testEnum != testEnum1.Value());
+
+        Core::EnumerateType<TestEnum> testEnum2(testEnum1);
+        Core::EnumerateType<TestEnum> testEnum3;
+        testEnum3 = testEnum1;
+        EXPECT_TRUE(testEnum3 == testEnum1);
+        testEnum3 = testEnum1.Value(); 
+    }
+
+    TEST(Core_Enumerate, FromEnumType)
+    {
+        TestEnum e = TestEnum::TWO;
+        Core::EnumerateType<TestEnum> testEnum(e);
+        EXPECT_EQ(testEnum, e);
+        EXPECT_TRUE(testEnum.IsSet());
+        EXPECT_EQ(testEnum.Value(), TestEnum::TWO);
+        EXPECT_STREQ(testEnum.Data(), "TWO");
+    }
+
+    TEST(Core_Enumerate, FromValue)
+    {
+        Core::EnumerateType<TestEnum> testEnum(1);
+        EXPECT_TRUE(testEnum.IsSet());
+        EXPECT_EQ(testEnum.Value(), TestEnum::TWO);
+        EXPECT_STREQ(testEnum.Data(), "TWO");
+
+        testEnum = 3;
+        EXPECT_FALSE(testEnum.IsSet());
+    }
+
+    TEST(Core_Enumerate, FromStringCaseSensitiveTrue)
+    {
+        Core::EnumerateType<TestEnum> testEnum("THREE");
+        EXPECT_TRUE(testEnum.IsSet());
+        EXPECT_EQ(testEnum.Value(), TestEnum::THREE);
+        EXPECT_STREQ(testEnum.Data(), "THREE");
+    }
+
+    TEST(Core_Enumerate, FromStringCaseSensitiveFalse)
+    {
+        Core::EnumerateType<TestEnum> testEnum("three");
+        EXPECT_FALSE(testEnum.IsSet());
+    }
+
+    TEST(Core_Enumerate, FromStringCaseInsensitive)
+    {
+        Core::EnumerateType<TestEnum> testEnum("three", false);
+        EXPECT_TRUE(testEnum.IsSet());
+        EXPECT_EQ(testEnum.Value(), TestEnum::THREE);
+        EXPECT_STREQ(testEnum.Data(), "THREE");
+    }
+
+    TEST(Core_Enumerate, FromTextFragmentCaseSensitiveTrue)
+    {
+        Core::TextFragment testFragment("THREE");
+        Core::EnumerateType<TestEnum> testEnum(testFragment);
+        EXPECT_TRUE(testEnum.IsSet());
+        EXPECT_EQ(testEnum.Value(), TestEnum::THREE);
+        EXPECT_STREQ(testEnum.Data(), "THREE");
+    }
+
+    TEST(Core_Enumerate, FromTextFragmentCaseSensitiveFalse)
+    {
+        Core::TextFragment testFragment("three");
+        Core::EnumerateType<TestEnum> testEnum(testFragment);
+        EXPECT_FALSE(testEnum.IsSet());
+    }
+
+    TEST(Core_Enumerate, FromTextFragmentCaseInsensitive)
+    {
+        Core::TextFragment testFragment("three");
+        Core::EnumerateType<TestEnum> testEnum(testFragment, false);
+        EXPECT_TRUE(testEnum.IsSet());
+        EXPECT_EQ(testEnum.Value(), TestEnum::THREE);
+        EXPECT_STREQ(testEnum.Data(), "THREE");
+    }
+} // Tests
+ENUM_CONVERSION_BEGIN(Tests::TestEnum)
+    { Tests::TestEnum::ONE, _TXT("ONE") },
+    { Tests::TestEnum::TWO, _TXT("TWO") },
+    { Tests::TestEnum::THREE, _TXT("THREE") },
+ENUM_CONVERSION_END(Tests::TestEnum)
+} // WPEFramework
diff --git b/Tests/core/test_event.cpp b/Tests/core/test_event.cpp
new file mode 100644
index 0000000..fb845b2
--- /dev/null
+++ b/Tests/core/test_event.cpp
@@ -0,0 +1,142 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+#include <thread>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+class ThreadClass : public Core::Thread {
+public:
+    ThreadClass() = delete;
+    ThreadClass(const ThreadClass&) = delete;
+    ThreadClass& operator=(const ThreadClass&) = delete;
+
+    ThreadClass(Event& event, std::thread::id parentTid, bool& threadDone, volatile bool& lock, volatile bool& setEvent, volatile bool& pulseEvent)
+        : Core::Thread(Core::Thread::DefaultStackSize(), _T("Test"))
+        , _threadDone(threadDone)
+        , _lock(lock)
+        , _setEvent(setEvent)
+        , _pulseEvent(pulseEvent)
+        , _event(event)
+        , _parentTid(parentTid)
+    {
+    }
+
+    virtual ~ThreadClass()
+    {
+    }
+
+    virtual uint32_t Worker() override
+    {
+        while (IsRunning() && (!_threadDone)) {
+            EXPECT_TRUE(_parentTid != std::this_thread::get_id());
+            ::SleepMs(50);
+            if (_lock) {
+                _threadDone = true;
+                _lock = false;
+                _event.Unlock();
+            }else if (_setEvent) {
+                _threadDone = true;
+                _setEvent = false;
+                _event.SetEvent();
+            }else if (_pulseEvent) {
+                _threadDone = true;
+                _pulseEvent = false;
+                _event.PulseEvent();
+            }
+        }
+        return (Core::infinite);
+    }
+private:
+    volatile bool&  _threadDone;
+    volatile bool&  _lock;
+    volatile bool&  _setEvent;
+    volatile bool&  _pulseEvent;
+    Event& _event;
+    std::thread::id _parentTid;
+};
+
+TEST(test_event, simple_event)
+{
+    Event event(false,true);
+    uint64_t timeOut(Core::Time::Now().Add(3).Ticks());
+    uint64_t now(Core::Time::Now().Ticks());
+    do
+    {
+        if (now < timeOut) {
+            event.Lock(static_cast<uint32_t>((timeOut - now) / Core::Time::TicksPerMillisecond));
+            EXPECT_FALSE(event.IsSet());
+        }
+    } while (timeOut < Core::Time::Now().Ticks());
+}
+
+TEST(test_event, unlock_event)
+{    
+    Event event(false,true);
+    std::thread::id parentTid;
+    bool threadDone = false;
+    volatile bool lock = true;
+    volatile bool setEvent = false;
+    volatile bool pulseEvent = false;
+
+    ThreadClass object(event, parentTid, threadDone, lock, setEvent, pulseEvent);
+    object.Run();
+    event.Lock();
+    EXPECT_FALSE(lock);
+    object.Stop();
+}
+
+TEST(test_event, set_event)
+{
+    Event event(false,true);
+    std::thread::id parentTid;
+    bool threadDone = false;
+    volatile bool lock = false;
+    volatile bool setEvent = true;
+    volatile bool pulseEvent = false;
+
+    event.ResetEvent();
+    ThreadClass object(event, parentTid, threadDone, lock, setEvent, pulseEvent);
+    object.Run();
+    event.Lock();
+    EXPECT_FALSE(setEvent);
+    object.Stop();     
+}
+
+TEST(test_event, pulse_event)
+{
+    Event event(false,true);
+    std::thread::id parentTid;
+    bool threadDone = false;
+    volatile bool lock = false;
+    volatile bool setEvent = false;
+    volatile bool pulseEvent = true;
+
+    event.ResetEvent();
+    ThreadClass object(event, parentTid, threadDone, lock, setEvent, pulseEvent);
+    object.Run();
+    event.Lock();
+    EXPECT_FALSE(pulseEvent);
+    object.Stop();
+}
diff --git b/Tests/core/test_filesystem.cpp b/Tests/core/test_filesystem.cpp
new file mode 100644
index 0000000..7f0a030
--- /dev/null
+++ b/Tests/core/test_filesystem.cpp
@@ -0,0 +1,100 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+TEST (test_file, file)
+{
+    File file;
+    File fileObj1("Sample.txt", true);
+    fileObj1.Create(true);
+    File fileObj2(fileObj1);
+    fileObj2.SetSize(150);
+
+    EXPECT_TRUE(fileObj1.Open());
+    EXPECT_TRUE(fileObj1.Append());
+    EXPECT_TRUE(fileObj1.Create());
+    EXPECT_TRUE(fileObj1.Create(Core::File::USER_WRITE));
+    EXPECT_TRUE(fileObj1.Open(true));
+
+    char buffer[] = "New  Line is added to the File.";
+    if (fileObj1.IsOpen()) {
+      fileObj1.Write(reinterpret_cast<uint8_t*>(buffer), sizeof(buffer));
+    }
+    if (fileObj1.IsOpen()) {
+        fileObj1.Read(reinterpret_cast<uint8_t*>(buffer), sizeof(buffer));
+    }
+
+    static string fileName = file.FileName("/home/file/datafile.txt");
+    EXPECT_EQ(fileName, "datafile");
+    static string filenameExt = file.FileNameExtended("/home/file/datafile.txt");
+    EXPECT_EQ(filenameExt, "datafile.txt");
+    static string pathName = file.PathName("/home/file/datafile.txt");
+    EXPECT_EQ(pathName, "/home/file/");
+    static string extension = file.Extension("/home/file/datafile.txt");
+    EXPECT_EQ(extension, "txt");
+    fileObj1.Destroy();
+}
+
+TEST (test_file, file_functions)
+{
+    File fileObj1("Sample2.txt", true);
+    fileObj1.Create(true);
+    char buffer[] = "Sample2.txt is moved to newFile.txt";
+    fileObj1.Write(reinterpret_cast<uint8_t*>(buffer), sizeof(buffer));
+    EXPECT_TRUE(fileObj1.IsOpen());
+    EXPECT_TRUE(fileObj1.Exists());
+    EXPECT_FALSE(fileObj1.IsReadOnly());
+    EXPECT_FALSE(fileObj1.IsHidden());
+    EXPECT_FALSE(fileObj1.IsSystem());
+    EXPECT_FALSE(fileObj1.IsArchive());
+    EXPECT_FALSE(fileObj1.IsDirectory());
+    EXPECT_FALSE(fileObj1.IsLink());
+    EXPECT_FALSE(fileObj1.IsCompressed());
+    EXPECT_FALSE(fileObj1.IsEncrypted());
+    uint64_t size = 0;
+    EXPECT_EQ(fileObj1.Size(), size);
+    EXPECT_EQ(fileObj1.DuplicateHandle(), 10);
+    EXPECT_TRUE(fileObj1.Move("newFile.txt"));
+}
+
+TEST (test_file, directory)
+{
+    Directory dir;
+    string path = "home/file";
+    Directory dirOne(path.c_str());
+    Directory dirTwo(path.c_str(), _T("*"));
+    Directory dirThree = dirOne ;
+
+    EXPECT_TRUE(dirOne.CreatePath());
+    EXPECT_FALSE(dirOne.Create());
+    EXPECT_FALSE(dirThree.IsValid());
+    EXPECT_TRUE(dirOne.Next());
+    EXPECT_EQ(dirOne.Current(), "home/file/.");
+    EXPECT_EQ(dirOne.Name(), ".");
+    EXPECT_TRUE(dirOne.IsDirectory());
+    dirOne.Reset();
+    EXPECT_TRUE(dirOne.Next());
+}
diff --git b/Tests/core/test_frametype.cpp b/Tests/core/test_frametype.cpp
new file mode 100644
index 0000000..3b3b58b
--- /dev/null
+++ b/Tests/core/test_frametype.cpp
@@ -0,0 +1,64 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+TEST(test_frame, simple_set)
+{
+    uint8_t arr[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
+    uint8_t arr1[] = {1,2,3,4,5,6,7,8,9,10,11,12,13};
+    const uint16_t BLOCKSIZE = 20;
+    FrameType<BLOCKSIZE> obj1;
+    FrameType<BLOCKSIZE> obj_copy(obj1);
+    FrameType<0> obj2(arr,15);
+    uint16_t len = 15;
+    uint16_t len1 = 13;
+    const uint16_t offset = 0;
+    EXPECT_EQ(obj1.SetBuffer<uint64_t>(offset,len,arr),23);
+    EXPECT_EQ(obj1.GetBuffer<uint64_t>(offset,len1,arr1),23);
+
+    FrameType<BLOCKSIZE>::Writer obj3(obj1,offset);
+    obj3.Buffer<uint64_t>(15,arr);
+    obj3.Copy(13, arr1);
+    obj3.Number<uint16_t>(4);
+    obj3.Boolean(TRUE);
+    obj3.Text("Frametype");
+    obj3.NullTerminatedText("Frametype");
+
+    obj1.Size(5000);
+    FrameType<BLOCKSIZE>::Reader obj4(obj1,offset);
+    obj4.Buffer<uint16_t>(15,arr);
+    obj4.Copy(13,arr1);
+    obj4.Number<uint16_t>();
+    obj4.Boolean();
+    obj4.Text();
+    obj4.NullTerminatedText();
+    obj4.UnlockBuffer(15);
+    // TODO: why doesn't this work when inlining is disabled?
+    //obj4.Dump();
+    uint32_t Size = 5000;
+    EXPECT_EQ(obj1.Size(),Size);
+    obj1.Clear();
+}
diff --git a/Tests/core/test_hex2strserialization.cpp b/Tests/core/test_hex2strserialization.cpp
index 82535e1..9839714 100644
--- a/Tests/core/test_hex2strserialization.cpp
+++ b/Tests/core/test_hex2strserialization.cpp
@@ -16,6 +16,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 #include <functional>
 #include <sstream>
 
diff --git b/Tests/core/test_ipc.cpp b/Tests/core/test_ipc.cpp
new file mode 100644
index 0000000..904f410
--- /dev/null
+++ b/Tests/core/test_ipc.cpp
@@ -0,0 +1,503 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+namespace WPEFramework {
+namespace Tests {
+
+    class Response {
+    public:
+        Response()
+            : _result(0)
+        {
+        }
+
+        Response(const uint32_t result)
+            : _result(result)
+        {
+        }
+
+        Response(const Response& copy)
+            : _result(copy._result)
+        {
+        }
+
+        ~Response()
+        {
+        }
+
+        Response& operator=(const Response& RHS)
+        {
+            _result = RHS._result;
+
+            return (*this);
+        }
+
+    public:
+        inline uint32_t Result() const
+        {
+            return (_result);
+        }
+
+    private:
+        uint32_t _result;
+    };
+
+    class Triplet {
+    public:
+        Triplet()
+            : _display(0)
+            , _surface(1)
+            , _context(2)
+        {
+        }
+
+        Triplet(const uint16_t display, const uint32_t surface, const uint64_t context)
+            : _display(display)
+            , _surface(surface)
+            , _context(context)
+        {
+        }
+
+        Triplet(const Triplet& copy)
+            : _display(copy._display)
+            , _surface(copy._surface)
+            , _context(copy._context)
+        {
+        }
+
+        ~Triplet()
+        {
+        }
+
+        Triplet& operator=(const Triplet& RHS)
+        {
+            _display = RHS._display;
+            _surface = RHS._surface;
+            _context = RHS._context;
+
+            return (*this);
+        }
+
+    public:
+        inline uint16_t Display() const
+        {
+            return (_display);
+        }
+
+        inline uint32_t Surface() const
+        {
+            return (_surface);
+        }
+
+        inline uint64_t Context() const
+        {
+            return (_context);
+        }
+
+    private:
+        uint16_t _display;
+        uint32_t _surface;
+        uint64_t _context;
+    };
+
+    typedef Core::IPCMessageType<1, Triplet, Response> TripletResponse;
+    typedef Core::IPCMessageType<2, Core::Void, Triplet> VoidTriplet;
+    typedef Core::IPCMessageType<3, Core::IPC::Text<2048>, Core::IPC::Text<2048>> TextText;
+
+    class HandleTripletResponse : public Core::IIPCServer {
+    public:
+        HandleTripletResponse(const HandleTripletResponse&) = delete;
+        HandleTripletResponse& operator=(const HandleTripletResponse&) = delete;
+
+        HandleTripletResponse()
+        {
+        }
+
+        virtual ~HandleTripletResponse()
+        {
+        }
+
+    public:
+        // Here comes the actual implementation of the RPC...
+        virtual void Procedure(Core::IPCChannel& source, Core::ProxyType<Core::IIPC>& data)
+        {
+            Core::ProxyType<TripletResponse> message(data);
+            uint32_t result = message->Parameters().Display() + message->Parameters().Surface() + static_cast<uint32_t>(message->Parameters().Context());
+
+            message->Response() = Response(result);
+            source.ReportResponse(data);
+        }
+    };
+
+    class HandleVoidTriplet : public Core::IIPCServer {
+    public:
+        HandleVoidTriplet(const HandleVoidTriplet&) = delete;
+        HandleVoidTriplet& operator=(const HandleVoidTriplet&) = delete;
+
+        HandleVoidTriplet()
+        {
+        }
+        virtual ~HandleVoidTriplet()
+        {
+        }
+
+    public:
+        // Here comes the actual implementation of the RPC...
+        virtual void Procedure(Core::IPCChannel& source, Core::ProxyType<Core::IIPC>& data)
+        {
+            Core::ProxyType<VoidTriplet> message(data);
+            Triplet newValue(1, 2, 3);
+
+            message->Response() = newValue;
+            source.ReportResponse(data);
+        }
+    };
+
+    class HandleTextText : public Core::IIPCServer {
+    public:
+        HandleTextText(const HandleTextText&) = delete;
+        HandleTextText& operator=(const HandleTextText&) = delete;
+
+        HandleTextText()
+        {
+        }
+
+        virtual ~HandleTextText()
+        {
+        }
+
+    public:
+        // Here comes the actual implementation of the RPC...
+        virtual void Procedure(Core::IPCChannel& source, Core::ProxyType<Core::IIPC>& data)
+        {
+            Core::ProxyType<TextText> message(data);
+            string text = message->Parameters().Value();
+
+            message->Response() = Core::IPC::Text<2048>(text);
+            source.ReportResponse(data);
+        }
+    };
+
+    TEST(Core_IPC, ContinuousChannel)
+    {
+        std::string connector = _T("/tmp/testserver0");
+        auto lambdaFunc = [connector](IPTestAdministrator & testAdmin) {
+            Core::NodeId continousNode(connector.c_str());
+            uint32_t error;
+
+            Core::ProxyType<Core::FactoryType<Core::IIPC, uint32_t> > factory(Core::ProxyType<Core::FactoryType<Core::IIPC, uint32_t> >::Create());
+
+            factory->CreateFactory<TripletResponse>(2);
+            factory->CreateFactory<VoidTriplet>(2);
+            factory->CreateFactory<TextText>(2);
+
+            Core::IPCChannelClientType<Core::Void, true, false> continousChannel(continousNode, 32, factory);
+
+            Core::ProxyType<Core::IIPCServer> handler1(Core::ProxyType<HandleTripletResponse>::Create());
+            Core::ProxyType<Core::IIPCServer> handler2(Core::ProxyType<HandleVoidTriplet>::Create());
+            Core::ProxyType<Core::IIPCServer> handler3(Core::ProxyType<HandleTextText>::Create());
+
+            continousChannel.Register(TripletResponse::Id(), handler1);
+            continousChannel.Register(VoidTriplet::Id(), handler2);
+            continousChannel.Register(TextText::Id(), handler3);
+
+            error = continousChannel.Source().Open(1000); // Wait for 1 Second.
+            EXPECT_EQ(error, Core::ERROR_NONE);
+
+            testAdmin.Sync("setup server");
+            testAdmin.Sync("setup client");
+            testAdmin.Sync("done testing");
+
+            error = continousChannel.Source().Close(1000); // Wait for 1 second
+            EXPECT_EQ(error, Core::ERROR_NONE);
+            continousChannel.Unregister(TripletResponse::Id());
+            continousChannel.Unregister(VoidTriplet::Id());
+            continousChannel.Unregister(TextText::Id());
+
+            factory->DestroyFactories();
+        };
+
+        static std::function<void (IPTestAdministrator&)> lambdaVar = lambdaFunc;
+
+        IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin ) { lambdaVar(testAdmin); };
+
+        IPTestAdministrator testAdmin(otherSide);
+        {
+            Core::NodeId continousNode(connector.c_str());
+            uint32_t error;
+
+            testAdmin.Sync("setup server");
+
+            Core::ProxyType<Core::FactoryType<Core::IIPC, uint32_t> > factory(Core::ProxyType<Core::FactoryType<Core::IIPC, uint32_t> >::Create());
+
+            factory->CreateFactory<TripletResponse>(2);
+            factory->CreateFactory<VoidTriplet>(2);
+            factory->CreateFactory<TextText>(2);
+
+            Core::IPCChannelClientType<Core::Void, false, false> continousChannel(continousNode, 32, factory);
+
+            Core::ProxyType<Core::IIPCServer> handler1(Core::ProxyType<HandleTripletResponse>::Create());
+            Core::ProxyType<Core::IIPCServer> handler2(Core::ProxyType<HandleVoidTriplet>::Create());
+            Core::ProxyType<Core::IIPCServer> handler3(Core::ProxyType<HandleTextText>::Create());
+
+            error = continousChannel.Source().Open(1000); // Wait for 1 Second.
+            EXPECT_EQ(error, Core::ERROR_NONE);
+
+            testAdmin.Sync("setup client");
+
+            Core::ProxyType<TripletResponse> tripletResponseData(Core::ProxyType<TripletResponse>::Create(Triplet(1, 2, 3)));
+            Core::ProxyType<VoidTriplet> voidTripletData(Core::ProxyType<VoidTriplet>::Create());
+            string text = "test text";
+            Core::ProxyType<TextText> textTextData(Core::ProxyType<TextText>::Create(Core::IPC::Text<2048>(text)));
+
+            uint16_t display = 1;;
+            uint32_t surface = 2;
+            uint64_t context = 3;
+            uint32_t result = 6;
+
+            error = continousChannel.Invoke(tripletResponseData, 5000);
+            EXPECT_EQ(error, Core::ERROR_NONE);
+            EXPECT_EQ(tripletResponseData->Response().Result(), result);
+
+            error = continousChannel.Invoke(voidTripletData, 2000);
+            EXPECT_EQ(error, Core::ERROR_NONE);
+            EXPECT_EQ(voidTripletData->Response().Display(), display);
+            EXPECT_EQ(voidTripletData->Response().Surface(), surface);
+            EXPECT_EQ(voidTripletData->Response().Context(), context);
+
+            error = continousChannel.Invoke(textTextData, 2000);
+            EXPECT_EQ(error, Core::ERROR_NONE);
+            EXPECT_STREQ(textTextData->Response().Value(), text.c_str());
+
+            error = continousChannel.Source().Close(1000); // Wait for 1 second
+            EXPECT_EQ(error, Core::ERROR_NONE);
+
+            factory->DestroyFactories();
+            Core::Singleton::Dispose();
+        }
+        testAdmin.Sync("done testing");
+    }
+    TEST(Core_IPC, FlashChannel)
+    {
+        std::string connector = _T("/tmp/testserver1");
+        auto lambdaFunc = [connector](IPTestAdministrator & testAdmin) {
+            Core::NodeId flashNode(connector.c_str());
+            uint32_t error;
+
+            Core::ProxyType<Core::FactoryType<Core::IIPC, uint32_t> > factory(Core::ProxyType<Core::FactoryType<Core::IIPC, uint32_t> >::Create());
+
+            factory->CreateFactory<TripletResponse>(2);
+            factory->CreateFactory<VoidTriplet>(2);
+            factory->CreateFactory<TextText>(2);
+
+            Core::IPCChannelClientType<Core::Void, true, false> flashChannel(flashNode, 512, factory);
+
+            Core::ProxyType<Core::IIPCServer> handler1(Core::ProxyType<HandleTripletResponse>::Create());
+            Core::ProxyType<Core::IIPCServer> handler2(Core::ProxyType<HandleVoidTriplet>::Create());
+            Core::ProxyType<Core::IIPCServer> handler3(Core::ProxyType<HandleTextText>::Create());
+
+            flashChannel.Register(TripletResponse::Id(), handler1);
+            flashChannel.Register(VoidTriplet::Id(), handler2);
+            flashChannel.Register(TextText::Id(), handler3);
+
+            error = flashChannel.Source().Open(1000); // Wait for 1 Second.
+            EXPECT_EQ(error, Core::ERROR_NONE);
+
+            testAdmin.Sync("setup server");
+            testAdmin.Sync("setup client");
+            testAdmin.Sync("done testing");
+
+            error = flashChannel.Source().Close(1000); // Wait for 1 Second
+            EXPECT_EQ(error, Core::ERROR_NONE);
+            flashChannel.Unregister(TripletResponse::Id());
+            flashChannel.Unregister(VoidTriplet::Id());
+            flashChannel.Unregister(TextText::Id());
+
+            factory->DestroyFactories();
+        };
+
+        static std::function<void (IPTestAdministrator&)> lambdaVar = lambdaFunc;
+
+        IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin ) { lambdaVar(testAdmin); };
+
+        IPTestAdministrator testAdmin(otherSide);
+        {
+            Core::NodeId flashNode(connector.c_str());
+            uint32_t error;
+
+            testAdmin.Sync("setup server");
+
+            Core::ProxyType<Core::FactoryType<Core::IIPC, uint32_t> > factory(Core::ProxyType<Core::FactoryType<Core::IIPC, uint32_t> >::Create());
+
+            factory->CreateFactory<TripletResponse>(2);
+            factory->CreateFactory<VoidTriplet>(2);
+            factory->CreateFactory<TextText>(2);
+
+            Core::IPCChannelClientType<Core::Void, false, false> flashChannel(flashNode, 512, factory);
+
+            Core::ProxyType<Core::IIPCServer> handler1(Core::ProxyType<HandleTripletResponse>::Create());
+            Core::ProxyType<Core::IIPCServer> handler2(Core::ProxyType<HandleVoidTriplet>::Create());
+            Core::ProxyType<Core::IIPCServer> handler3(Core::ProxyType<HandleTextText>::Create());
+
+            testAdmin.Sync("setup client");
+
+            Core::ProxyType<TripletResponse> tripletResponseData(Core::ProxyType<TripletResponse>::Create(Triplet(1, 2, 3)));
+            Core::ProxyType<VoidTriplet> voidTripletData(Core::ProxyType<VoidTriplet>::Create());
+            string text = "test text";
+            Core::ProxyType<TextText> textTextData(Core::ProxyType<TextText>::Create(Core::IPC::Text<2048>(text)));
+
+            uint16_t display = 1;;
+            uint32_t surface = 2;
+            uint64_t context = 3;
+            uint32_t result = 6;
+
+            error = flashChannel.Source().Open(1000); // Wait for 1 Second.
+            EXPECT_EQ(error, Core::ERROR_NONE);
+            error = flashChannel.Invoke(tripletResponseData, 2000);
+            EXPECT_EQ(error, Core::ERROR_NONE);
+            EXPECT_EQ(tripletResponseData->Response().Result(), result);
+            error = flashChannel.Source().Close(1000); // Wait for 1 Second
+            EXPECT_EQ(error, Core::ERROR_NONE);
+
+            error = flashChannel.Source().Open(1000); // Wait for 1 Second.
+            EXPECT_EQ(error, Core::ERROR_NONE);
+            error = flashChannel.Invoke(voidTripletData, 2000);
+            EXPECT_EQ(error, Core::ERROR_NONE);
+            EXPECT_EQ(voidTripletData->Response().Display(), display);
+            EXPECT_EQ(voidTripletData->Response().Surface(), surface);
+            EXPECT_EQ(voidTripletData->Response().Context(), context);
+            error = flashChannel.Source().Close(1000); // Wait for 1 Second
+            EXPECT_EQ(error, Core::ERROR_NONE);
+
+            error = flashChannel.Source().Open(1000); // Wait for 1 Second.
+            EXPECT_EQ(error, Core::ERROR_NONE);
+            error = flashChannel.Invoke(textTextData, 2000);
+            EXPECT_EQ(error, Core::ERROR_NONE);
+            EXPECT_STREQ(textTextData->Response().Value(), text.c_str());
+            error = flashChannel.Source().Close(1000); // Wait for 1 Second
+            EXPECT_EQ(error, Core::ERROR_NONE);
+
+            factory->DestroyFactories();
+            Core::Singleton::Dispose();
+        }
+        testAdmin.Sync("done testing");
+    }
+    TEST(Core_IPC, MultiChannel)
+    {
+        std::string connector = _T("/tmp/testserver2");
+        auto lambdaFunc = [connector](IPTestAdministrator & testAdmin) {
+            Core::NodeId multiNode(connector.c_str());
+            uint32_t error;
+
+            Core::ProxyType<Core::FactoryType<Core::IIPC, uint32_t> > factory(Core::ProxyType<Core::FactoryType<Core::IIPC, uint32_t> >::Create());
+
+            factory->CreateFactory<TripletResponse>(2);
+            factory->CreateFactory<VoidTriplet>(2);
+            factory->CreateFactory<TextText>(2);
+
+            Core::IPCChannelServerType<Core::Void, false> multiChannel(multiNode, 512, factory);
+
+            Core::ProxyType<Core::IIPCServer> handler1(Core::ProxyType<HandleTripletResponse>::Create());
+            Core::ProxyType<Core::IIPCServer> handler2(Core::ProxyType<HandleVoidTriplet>::Create());
+            Core::ProxyType<Core::IIPCServer> handler3(Core::ProxyType<HandleTextText>::Create());
+
+            multiChannel.Register(TripletResponse::Id(), handler1);
+            multiChannel.Register(VoidTriplet::Id(), handler2);
+            multiChannel.Register(TextText::Id(), handler3);
+
+            error = multiChannel.Open(1000); // Wait for 1 Second.
+            EXPECT_EQ(error, Core::ERROR_NONE);
+
+            testAdmin.Sync("setup server");
+            testAdmin.Sync("setup client");
+            testAdmin.Sync("done testing");
+
+            error = multiChannel.Close(1000); // Wait for 1 Second.
+            EXPECT_EQ(error, Core::ERROR_NONE);
+
+            factory->DestroyFactories();
+        };
+
+        static std::function<void (IPTestAdministrator&)> lambdaVar = lambdaFunc;
+
+        IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin ) { lambdaVar(testAdmin); };
+
+        IPTestAdministrator testAdmin(otherSide);
+        {
+            Core::NodeId multiNode(connector.c_str());
+            uint32_t error;
+
+            testAdmin.Sync("setup server");
+
+            Core::ProxyType<Core::FactoryType<Core::IIPC, uint32_t> > factory(Core::ProxyType<Core::FactoryType<Core::IIPC, uint32_t> >::Create());
+
+            factory->CreateFactory<TripletResponse>(2);
+            factory->CreateFactory<VoidTriplet>(2);
+            factory->CreateFactory<TextText>(2);
+
+            Core::IPCChannelClientType<Core::Void, false, false> multiChannel(multiNode, 512, factory);
+
+            Core::ProxyType<Core::IIPCServer> handler1(Core::ProxyType<HandleTripletResponse>::Create());
+            Core::ProxyType<Core::IIPCServer> handler2(Core::ProxyType<HandleVoidTriplet>::Create());
+            Core::ProxyType<Core::IIPCServer> handler3(Core::ProxyType<HandleTextText>::Create());
+
+            error = multiChannel.Source().Open(1000); // Wait for 1 Second.
+            EXPECT_EQ(error, Core::ERROR_NONE);
+
+            testAdmin.Sync("setup client");
+
+            Core::ProxyType<TripletResponse> tripletResponseData(Core::ProxyType<TripletResponse>::Create(Triplet(1, 2, 3)));
+            Core::ProxyType<VoidTriplet> voidTripletData(Core::ProxyType<VoidTriplet>::Create());
+            string text = "test text";
+            Core::ProxyType<TextText> textTextData(Core::ProxyType<TextText>::Create(Core::IPC::Text<2048>(text)));
+
+            uint16_t display = 1;;
+            uint32_t surface = 2;
+            uint64_t context = 3;
+            uint32_t result = 6;
+
+            error = multiChannel.Invoke(tripletResponseData, 2000);
+            EXPECT_EQ(error, Core::ERROR_NONE);
+            EXPECT_EQ(tripletResponseData->Response().Result(), result);
+
+            error = multiChannel.Invoke(voidTripletData, 2000);
+            EXPECT_EQ(error, Core::ERROR_NONE);
+            EXPECT_EQ(voidTripletData->Response().Display(), display);
+            EXPECT_EQ(voidTripletData->Response().Surface(), surface);
+            EXPECT_EQ(voidTripletData->Response().Context(), context);
+
+            error = multiChannel.Invoke(textTextData, 2000);
+            EXPECT_EQ(error, Core::ERROR_NONE);
+            EXPECT_STREQ(textTextData->Response().Value(), text.c_str());
+
+            error = multiChannel.Source().Close(1000); // Wait for 1 Second.
+            EXPECT_EQ(error, Core::ERROR_NONE);
+
+            factory->DestroyFactories();
+            Core::Singleton::Dispose();
+        }
+        testAdmin.Sync("done testing");
+    }
+} // Tests
+} // WPEFramework
diff --git b/Tests/core/test_iso639.cpp b/Tests/core/test_iso639.cpp
new file mode 100644
index 0000000..7fedc75
--- /dev/null
+++ b/Tests/core/test_iso639.cpp
@@ -0,0 +1,43 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+TEST(test_ISO639, simple_ISO639)
+{
+    Language();
+    Language lang("eng");
+    Language(12);
+    Language lang1(" ");
+    Language lang2("en");
+    Language lang3("aaaaaa");
+     
+    EXPECT_TRUE(lang.IsValid());
+    EXPECT_STREQ(lang.LetterCode3(),"eng");
+    EXPECT_STREQ(lang.LetterCode2(),"en");
+    EXPECT_STREQ(lang.Description(),"Engels");
+    EXPECT_EQ(lang.Id(),127);
+}
+
diff --git b/Tests/core/test_iterator.cpp b/Tests/core/test_iterator.cpp
new file mode 100644
index 0000000..861edcc
--- /dev/null
+++ b/Tests/core/test_iterator.cpp
@@ -0,0 +1,156 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+namespace WPEFramework {
+namespace Tests {
+
+    class DataClass {
+    public:
+        DataClass() = delete;
+
+        DataClass(uint8_t value)
+            : _value(value)
+        {
+        }
+
+        ~DataClass()
+        {
+        }
+
+        uint8_t Value()
+        {
+            return _value;
+        }
+    private:
+        uint8_t _value;
+    };
+
+    template <typename CONTAINER, typename ELEMENT>
+    class IteratorClass : public Core::IteratorType<CONTAINER, ELEMENT>
+    {
+    private:
+        typedef Core::IteratorType<CONTAINER, ELEMENT> BaseClass;
+    public:
+        IteratorClass() =delete;
+
+        IteratorClass(CONTAINER& container)
+            : BaseClass(container)
+        {
+            EXPECT_EQ(container, *(BaseClass::Container()));
+        }
+
+        ~IteratorClass()
+        {
+        }
+    };
+
+    template <typename CONTAINER, typename ELEMENT, typename KEY>
+    class IteratorMapClass : public Core::IteratorMapType<CONTAINER, ELEMENT, KEY>
+    {
+    private:
+        typedef Core::IteratorMapType<CONTAINER, ELEMENT, KEY> BaseClass;
+
+    public:
+        IteratorMapClass() = delete;
+
+        IteratorMapClass(CONTAINER& container)
+            : BaseClass(container)
+        {
+            EXPECT_EQ(container, *(BaseClass::Container()));
+        }
+
+        ~IteratorMapClass()
+        {
+        }
+    };
+
+    typedef IteratorClass<std::list<DataClass*>, DataClass*> DataIterator;
+    typedef IteratorMapClass<std::map<uint8_t, DataClass*>, DataClass*, uint8_t> DataMapIterator;
+
+    template <typename T>
+    void Validate(T iterator, uint8_t index)
+    {
+        EXPECT_EQ(index, iterator.Index());
+        if ((index > 0) && (index < 4)) {
+            EXPECT_EQ(index, (*iterator)->Value());
+            EXPECT_EQ(index, iterator.Current()->Value());
+            EXPECT_EQ(index, iterator->Value());
+        }
+    }
+
+    template <typename T>
+    void ValidateMap(T iterator, uint8_t index)
+    {
+        EXPECT_EQ(index, iterator.Index());
+        if ((index > 0) && (index < 4)) {
+            EXPECT_EQ(index, (*iterator)->Value());
+            EXPECT_EQ(index, iterator.Current()->Value());
+            EXPECT_EQ(index, iterator->Value());
+            EXPECT_EQ(index, iterator.Key());
+        }
+    }
+
+    TEST(Core_IIterator, IteratorType)
+    {
+        DataClass entry1(1);
+        DataClass entry2(2);
+        DataClass entry3(3);
+        std::list<DataClass*> list{&entry1, &entry2, &entry3};
+        DataIterator iterator(list);
+        EXPECT_EQ(iterator.Count(), 3u);
+
+        for (uint8_t i = 0; i <= 4; i++) {
+            iterator.Reset(i);
+            Validate<DataIterator>(iterator, i);
+        }
+
+        for (uint8_t i = 3; iterator.Previous(); i--)
+            Validate<DataIterator>(iterator, i);
+
+        for (uint8_t i = 1; iterator.Next(); i++)
+            Validate<DataIterator>(iterator, i);
+    }
+
+    TEST(Core_IIterator, IteratorMapType)
+    {
+        DataClass entry1(1);
+        DataClass entry2(2);
+        DataClass entry3(3);
+        std::map<uint8_t, DataClass*> map{{1, &entry1}, {2, &entry2}, {3, &entry3}};    
+        DataMapIterator iterator(map);
+        EXPECT_EQ(iterator.Count(), 3u);
+
+        for (uint8_t i = 0; i <= 4; i++) {
+            iterator.Reset(i);
+            ValidateMap<DataMapIterator>(iterator, i);
+        }
+
+        for (uint8_t i = 3; iterator.Previous(); i--)
+            ValidateMap<DataMapIterator>(iterator, i);
+
+        for (uint8_t i = 1; iterator.Next(); i++)
+            ValidateMap<DataMapIterator>(iterator, i);
+    }
+} // Tests
+} // WPEFramework
diff --git b/Tests/core/test_json.cpp b/Tests/core/test_json.cpp
new file mode 100644
index 0000000..bcdfed6
--- /dev/null
+++ b/Tests/core/test_json.cpp
@@ -0,0 +1,193 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+
+enum class CommandType {
+    ENUM_1,
+    ENUM_2,
+    ENUM_3,
+    ENUM_4
+};
+
+namespace WPEFramework {
+
+    ENUM_CONVERSION_BEGIN(CommandType)
+        { CommandType::ENUM_1, _TXT("enum_1") },
+        { CommandType::ENUM_2, _TXT("enum_2") },
+        { CommandType::ENUM_3, _TXT("enum_3") },
+        { CommandType::ENUM_4, _TXT("enum_4") },
+    ENUM_CONVERSION_END(CommandType)
+
+}
+
+class CommandParameters : public WPEFramework::Core::JSON::Container {
+
+public:
+    CommandParameters(const CommandParameters&) = delete;
+    CommandParameters& operator=(const CommandParameters&) = delete;
+
+    CommandParameters()
+        : Core::JSON::Container()
+        , G(00)
+        , H(0)
+        , I()
+        , J()
+    {
+        Add(_T("g"), &G);
+        Add(_T("h"), &H);
+        Add(_T("i"), &I);
+        Add(_T("j"), &J);
+    }
+
+    ~CommandParameters()
+    {
+    }
+
+public:
+    WPEFramework::Core::JSON::OctSInt16 G;
+    WPEFramework::Core::JSON::DecSInt16 H;
+    WPEFramework::Core::JSON::EnumType<CommandType> I;
+    WPEFramework::Core::JSON::ArrayType<WPEFramework::Core::JSON::DecUInt16> J;
+};
+
+class CommandRequest : public WPEFramework::Core::JSON::Container {
+public:
+    CommandRequest(const CommandRequest&) = delete;
+    CommandRequest& operator=(const CommandRequest&) = delete;
+
+public:
+    CommandRequest()
+        : Core::JSON::Container()
+        , A(0x0)
+        , B()
+        , C(0x0)
+        , D(false)
+        , E(00)
+        , F()
+    {
+        Add(_T("a"), &A);
+        Add(_T("b"), &B);
+        Add(_T("c"), &C);
+        Add(_T("d"), &D);
+        Add(_T("e"), &E);
+        Add(_T("f"), &F);
+    }
+
+    ~CommandRequest()
+    {
+    }
+
+public:
+    WPEFramework::Core::JSON::HexSInt32 A;
+    WPEFramework::Core::JSON::String B;
+    WPEFramework::Core::JSON::HexUInt32 C;
+    WPEFramework::Core::JSON::Boolean D;
+    WPEFramework::Core::JSON::OctUInt16 E;
+    CommandParameters F;
+};
+
+TEST(Core_JSON, simpleSet)
+{
+    {
+        //Tester
+        string input = R"({"a":"-0x5A","b":"TestIdentifier","c":"0x5A","d":true,"e":"014","f":{"g":"-014","h":"-44","i":"enum_4","j":["6","14","22"]}})";
+        string inputRequired = R"({"a":"-0x5A","b":"TestIdentifier","c":"0x5A","d":true,"e":"014","f":{"g":"-014","h":-44,"i":"enum_4","j":[6,14,22]}})";
+        string output;
+        WPEFramework::Core::ProxyType<CommandRequest> command = WPEFramework::Core::ProxyType<CommandRequest>::Create();
+        command->A = -90;
+        command->B = _T("TestIdentifier");
+        command->C = 90;
+        command->D = true;
+        command->E = 12;
+        command->F.G = -12;
+        command->F.H = -44;
+        command->F.I = CommandType::ENUM_4;
+        command->F.J.Add(WPEFramework::Core::JSON::DecUInt16(6, true));
+        command->F.J.Add(WPEFramework::Core::JSON::DecUInt16(14, true));
+        command->F.J.Add(WPEFramework::Core::JSON::DecUInt16(22, true));
+        WPEFramework::Core::JSON::Tester<1, CommandRequest> parser;
+        //ToString
+        parser.ToString(command, output);
+        ASSERT_STREQ(inputRequired.c_str(), output.c_str());
+        //FromString
+        WPEFramework::Core::ProxyType<CommandRequest> received = WPEFramework::Core::ProxyType<CommandRequest>::Create();
+        parser.FromString(input, received);
+        output.clear();
+        parser.ToString(received, output);
+        ASSERT_STREQ(inputRequired.c_str(), output.c_str());
+
+        parser.FromString(inputRequired, received);
+        output.clear();
+        parser.ToString(received, output);
+        ASSERT_STREQ(inputRequired.c_str(), output.c_str());
+
+        //ArrayType Iterator
+        WPEFramework::Core::JSON::ArrayType<Core::JSON::DecUInt16>::Iterator settings(command->F.J.Elements());
+        for(int i = 0; settings.Next(); i++)
+            ASSERT_EQ(settings.Current().Value(), command->F.J[i]);
+        //null test
+        input = R"({"a":null,"b":null,"c":"0x5A","d":null,"f":{"g":"-014","h":-44}})";
+        parser.FromString(input, received);
+        output.clear();
+        parser.ToString(received, output);
+        //ASSERT_STREQ(input.c_str(), output.c_str());
+    }
+    //JsonObject and JsonValue
+    {
+        string input = R"({"a":"-0x5A","b":"TestIdentifier","c":"0x5A","d":true,"e":"014","f":{"g":"-014","h":-44,"i":"enum_4","j":[6,14,22]}})";
+        JsonObject command;
+        command.FromString(input);
+        string output;
+        command.ToString(output);
+        ASSERT_STREQ(input.c_str(), output.c_str());
+
+        JsonObject object;
+        object["g"] = "-014";
+        object["h"] = -44;
+        object["i"] = "enum_4";
+        JsonArray arrayValue;
+        arrayValue.Add(6);
+        arrayValue.Add(14);
+        arrayValue.Add(22);
+        object["j"] = arrayValue;
+        JsonObject demoObject;
+        demoObject["a"] = "-0x5A";
+        demoObject["b"] = "TestIdentifier";
+        demoObject["c"] = "0x5A";
+        demoObject["d"] = true;
+        demoObject["e"] = "014";
+        demoObject["f"] = object;
+        string serialized;
+        demoObject.ToString(serialized);
+        ASSERT_STREQ(input.c_str(), serialized.c_str());
+
+        JsonObject::Iterator index = demoObject.Variants();
+        while (index.Next()) {
+            JsonValue value(demoObject.Get(index.Label()));
+            ASSERT_EQ(value.Content(), index.Current().Content());
+            ASSERT_STREQ(value.Value().c_str(), index.Current().Value().c_str());
+        }
+    }
+}
diff --git a/Tests/core/test_jsonparser.cpp b/Tests/core/test_jsonparser.cpp
index 445c30c..007e2f8 100644
--- a/Tests/core/test_jsonparser.cpp
+++ b/Tests/core/test_jsonparser.cpp
@@ -218,10 +218,10 @@ namespace Tests {
         data.valueToPutInJson = data.value;
         ExecutePrimitiveJsonTest<Core::JSON::ArrayType<Core::JSON::String>>(
             data, true, [](const Core::JSON::ArrayType<Core::JSON::String>& v) {
-                ASSERT_EQ(2u, v.Length());
-                EXPECT_NE(string{}, v[0].Value());
-                EXPECT_NE(string{}, v[1].Value());
-            });
+            ASSERT_EQ(2u, v.Length());
+            EXPECT_NE(string{}, v[0].Value());
+            EXPECT_NE(string{}, v[1].Value());
+        });
     }
 
     TEST(JSONParser, NullArray)
@@ -233,8 +233,8 @@ namespace Tests {
         data.valueToPutInJson = data.value;
         ExecutePrimitiveJsonTest<Core::JSON::ArrayType<Core::JSON::String>>(
             data, true, [](const Core::JSON::ArrayType<Core::JSON::String>& v) {
-                EXPECT_TRUE(v.IsNull());
-            });
+            EXPECT_TRUE(v.IsNull());
+        });
     }
 
     TEST(JSONParser, IntendedNullArrayButMissed)
@@ -246,8 +246,8 @@ namespace Tests {
         data.valueToPutInJson = data.value;
         ExecutePrimitiveJsonTest<Core::JSON::ArrayType<Core::JSON::String>>(
             data, false, [](const Core::JSON::ArrayType<Core::JSON::String>& v) {
-                EXPECT_EQ(0u, v.Length());
-            });
+            EXPECT_EQ(0u, v.Length());
+        });
     }
 
     TEST(JSONParser, ArrayWithCommaOnly)
@@ -259,8 +259,8 @@ namespace Tests {
         data.valueToPutInJson = "[,]";
         ExecutePrimitiveJsonTest<Core::JSON::ArrayType<Core::JSON::String>>(
             data, false, [](const Core::JSON::ArrayType<Core::JSON::String>& v) {
-                EXPECT_EQ(0u, v.Length());
-            });
+            EXPECT_EQ(0u, v.Length());
+        });
     }
 
     TEST(JSONParser, WronglyOpenedArray)
@@ -271,8 +271,8 @@ namespace Tests {
         data.valueToPutInJson = "(\"Foo\"]";
         ExecutePrimitiveJsonTest<Core::JSON::ArrayType<Core::JSON::String>>(
             data, false, [](const Core::JSON::ArrayType<Core::JSON::String>& v) {
-                EXPECT_EQ(0u, v.Length());
-            });
+            EXPECT_EQ(0u, v.Length());
+        });
     }
 
     TEST(JSONParser, WronglyClosedArray1)
@@ -283,8 +283,8 @@ namespace Tests {
         data.valueToPutInJson = "[\"Foo\"}";
         ExecutePrimitiveJsonTest<Core::JSON::ArrayType<Core::JSON::String>>(
             data, false, [](const Core::JSON::ArrayType<Core::JSON::String>& v) {
-                EXPECT_EQ(0u, v.Length());
-            });
+            EXPECT_EQ(0u, v.Length());
+        });
     }
 
     TEST(JSONParser, WronglyClosedArray2)
@@ -295,8 +295,8 @@ namespace Tests {
         data.valueToPutInJson = "[\"Foo\")";
         ExecutePrimitiveJsonTest<Core::JSON::ArrayType<Core::JSON::String>>(
             data, false, [](const Core::JSON::ArrayType<Core::JSON::String>& v) {
-                EXPECT_EQ(0u, v.Length());
-            });
+            EXPECT_EQ(0u, v.Length());
+        });
     }
 
     TEST(JSONParser, String)
@@ -367,18 +367,18 @@ namespace Tests {
         data.value = "value";
         data.valueToPutInJson = data.value;
         const bool expected =
-#ifdef QUIRKS_MODE
-            true
-#else
-            false
-#endif
-            ;
+        #ifdef QUIRKS_MODE
+        true
+        #else
+        false
+        #endif
+        ;
         ExecutePrimitiveJsonTest<Core::JSON::String>(data, expected, [&data](const Core::JSON::String& v) {
-#ifdef QUIRKS_MODE
+            #ifdef QUIRKS_MODE
             EXPECT_EQ(data.value, v.Value());
-#else
+            #else
             EXPECT_EQ(string{}, v.Value());
-#endif
+            #endif
         });
     }
 
@@ -401,17 +401,17 @@ namespace Tests {
         data.keyToPutInJson = "\"" + data.key + "\"";
         data.value = "value";
         data.valueToPutInJson = data.value + "\"";
-#ifndef QUIRKS_MODE
+        #ifndef QUIRKS_MODE
         const bool expected = false;
-#else
+        #else
         const bool expected = true;
-#endif
+        #endif
         ExecutePrimitiveJsonTest<Core::JSON::String>(data, expected, [&data](const Core::JSON::String& v) {
-#ifndef QUIRKS_MODE
+        #ifndef QUIRKS_MODE
             EXPECT_EQ(string{}, v.Value());
-#else
+        #else
             EXPECT_EQ(data.value + "\"", v.Value());
-#endif
+        #endif
         });
     }
 
@@ -569,11 +569,11 @@ namespace Tests {
         data.value = "1e2";
         data.valueToPutInJson = "\"" + data.value + "\"";
         ExecutePrimitiveJsonTest<Core::JSON::DecUInt8>(data, false, [](const Core::JSON::DecUInt8& v) {
-#ifndef QUIRKS_MODE
+        #ifndef QUIRKS_MODE
             EXPECT_EQ(100u, v.Value());
-#else
+        #else
             EXPECT_EQ(0x1E2, v.Value());
-#endif
+        #endif
         });
     }
 
@@ -695,7 +695,7 @@ namespace Tests {
         ExecutePrimitiveJsonTest<Core::JSON::Buffer>(data, false, nullptr);
     }
 
-#ifdef QUIRKS_MODE
+    #ifdef QUIRKS_MODE
     TEST(JSONParser, OpaqueObject)
     {
         TestData data;
@@ -714,9 +714,9 @@ namespace Tests {
         data.key = "key";
         data.keyToPutInJson = "\"" + data.key + "\"";
         data.value = "{\"" + data.key + "\":{\"key2\":{\"key2\":{\"key2\":{\"key2\":{\"key2\":{\"key2\":"
-                                        "{\"key2\":{\"key2\":{\"key2\":{\"key2\":{\"key2\":{\"key2\":{\"key2\":"
-                                        "{\"key2\":{\"key2\":{\"key2\":{\"key2\":{\"key2\":{\"key2\":{\"key2\":"
-                                        "{\"key2\":{\"key2\":{\"key2\":{\"key2\":\"value\"}}}}}}}}}}}}}}}}}}}}}}}}}";
+            "{\"key2\":{\"key2\":{\"key2\":{\"key2\":{\"key2\":{\"key2\":{\"key2\":"
+            "{\"key2\":{\"key2\":{\"key2\":{\"key2\":{\"key2\":{\"key2\":{\"key2\":"
+            "{\"key2\":{\"key2\":{\"key2\":{\"key2\":\"value\"}}}}}}}}}}}}}}}}}}}}}}}}}";
         data.valueToPutInJson = data.value;
         ExecutePrimitiveJsonTest<Core::JSON::String>(data, false, nullptr);
     }
@@ -744,7 +744,7 @@ namespace Tests {
             EXPECT_EQ(string{}, v.Value());
         });
     }
-#endif
+    #endif
 
     TEST(JSONParser, EnumValue)
     {
@@ -758,7 +758,7 @@ namespace Tests {
         });
     }
 
-    TEST(JSONParser, InvalidEnumValue)
+    TEST(DISABLED_JSONParser, InvalidEnumValue)
     {
         TestData data;
         data.key = "key";
@@ -770,9 +770,10 @@ namespace Tests {
 
 } // Tests
 
-ENUM_CONVERSION_BEGIN(Tests::JSONTestEnum){ WPEFramework::Tests::JSONTestEnum::ONE, _TXT("one") },
+ENUM_CONVERSION_BEGIN(Tests::JSONTestEnum)
+    { WPEFramework::Tests::JSONTestEnum::ONE, _TXT("one") },
     { WPEFramework::Tests::JSONTestEnum::TWO, _TXT("two") },
-    ENUM_CONVERSION_END(Tests::JSONTestEnum)
+ENUM_CONVERSION_END(Tests::JSONTestEnum)
 
 } // WPEFramework
 
diff --git b/Tests/core/test_keyvalue.cpp b/Tests/core/test_keyvalue.cpp
new file mode 100644
index 0000000..5eefcdf
--- /dev/null
+++ b/Tests/core/test_keyvalue.cpp
@@ -0,0 +1,59 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+
+TEST(test_keyvaluetype, simple_keyvaluetype)
+{
+    string key = "Name";
+    string value = "Adam";
+    string key1 = "Age";
+   
+    KeyValueType<string,string> keyvalue(key);
+    KeyValueType<string,string> keyvalue1(key,value);
+    KeyValueType<string,string> keyvalue2(keyvalue1);
+    KeyValueType<string,string> keyvalue3(key);
+    keyvalue3 = keyvalue1;
+    KeyValueType<string,string> keyvalue4(key1);
+
+    EXPECT_TRUE(keyvalue3 == keyvalue1);
+    EXPECT_TRUE(keyvalue3 != keyvalue4);
+    
+    EXPECT_STREQ(keyvalue3.Key().c_str(),key.c_str());
+    EXPECT_STREQ(keyvalue3.Value().c_str(),value.c_str());
+    EXPECT_TRUE(keyvalue3.IsKey(key));
+}
+TEST(test_textkeyvaluetype, simple_textkeyvaluetype)
+{
+   string buffer = "/Service/testing/test";
+   TextFragment key;
+   key = TextFragment(string(buffer));
+   OptionalType<TextFragment> value = TextFragment(string(buffer));
+   const bool CASESENSITIVE = true;
+
+   TextKeyValueType<CASESENSITIVE, TextFragment> textkeyvaluetype();
+   TextKeyValueType<CASESENSITIVE, TextFragment> textkeyvaluetype1(key, value);
+}
diff --git b/Tests/core/test_library.cpp b/Tests/core/test_library.cpp
new file mode 100644
index 0000000..50713ad
--- /dev/null
+++ b/Tests/core/test_library.cpp
@@ -0,0 +1,45 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+TEST(Core_Library, simpleSet)
+{
+    Library libObj;
+    //const string file = string(BUILD_DIR) + _T("/../../Source/core/libWPEFrameworkCore.so");
+    const string file =  _T("/usr/lib/libwpe-0.2.so"); //For box.
+    const TCHAR* function = _T("Core::Library::AddRef()");
+    const string file1 = _T("libWPEFramework.so");
+    Library LibObj1(file.c_str());
+    LibObj1.LoadFunction(function);
+    Library LibObjTest(file1.c_str());
+    Library LibObj2(LibObj1);
+    Library LibObj3;
+    LibObj3 = LibObj2;
+
+    EXPECT_TRUE(LibObj1.IsLoaded());
+    EXPECT_EQ(LibObj3.Error(), "");
+    EXPECT_EQ(LibObj3.Name(), file);
+}
diff --git b/Tests/core/test_lockablecontainer.cpp b/Tests/core/test_lockablecontainer.cpp
new file mode 100644
index 0000000..4889099
--- /dev/null
+++ b/Tests/core/test_lockablecontainer.cpp
@@ -0,0 +1,56 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+class Container
+{
+    public:
+        Container()
+            : _length(0)
+            , _data(nullptr)
+        {
+        }
+
+        ~Container()
+        {
+        }
+
+    private:
+        int _length;
+        int* _data;
+};
+TEST(test_lockableContainer, lockContainer_test)
+{
+    LockableContainerType<Container> containerObj1;
+    LockableContainerType<Container> containerObj2(containerObj1);
+    LockableContainerType<Container> containerObj3;
+    containerObj3 = containerObj2;
+
+    EXPECT_TRUE(containerObj1.ReadLock());
+    containerObj1.ReadUnlock();
+    EXPECT_TRUE(containerObj2.WriteLock());
+    containerObj2.WriteUnlock();
+}
diff --git b/Tests/core/test_logging.cpp b/Tests/core/test_logging.cpp
new file mode 100644
index 0000000..1c81be2
--- /dev/null
+++ b/Tests/core/test_logging.cpp
@@ -0,0 +1,52 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <tracing/Logging.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+/* Prior to test execution, please export LOGGING_TO_CONSOLE=1*/
+TEST(tracing_logging, simple_loggings)
+{
+   Logging::SysLog(true);
+   Logging::LoggingType<Logging::Startup> loggingType("hello");
+   Logging::LoggingType<Logging::Startup>::Enable((0x00000001) != 0);
+   Logging::LoggingType<Logging::Shutdown>::Enable((0x00000002) != 0);
+   Logging::LoggingType<Logging::Notification>::Enable((0x00000004) != 0);
+   SYSLOG(Logging::Notification, ("Logging utility verification"));
+   SYSLOG(Logging::Startup, ("Logging utility verification"));
+   Logging::SysLog(false);
+   SYSLOG(Logging::Shutdown, ("Logging utility verification"));
+
+   EXPECT_STREQ("SysLog",Logging::LoggingType<Logging::Notification>("Hello").Module());
+   EXPECT_STREQ("Notification",Logging::LoggingType<Logging::Notification>("Hello").Category());
+   EXPECT_STREQ("Hello",Logging::LoggingType<Logging::Notification>("Hello").Data());
+   EXPECT_EQ(Logging::LoggingType<Logging::Notification>("Hello").Length(),5);
+   EXPECT_EQ(Logging::LoggingType<Logging::Startup>("Hello").Length(),5);
+   EXPECT_EQ(Logging::LoggingType<Logging::Shutdown>("Hello").Length(),5);
+   EXPECT_TRUE(Logging::LoggingType<Logging::Notification>("Hello").Enabled()) << "TraceControl not Enabled";
+   Logging::LoggingType<Logging::Notification>("Hello").Enabled(true);
+   Logging::LoggingType<Logging::Notification>("Hello").Destroy();
+
+   Core::Singleton::Dispose();
+}
diff --git b/Tests/core/test_measurementtype.cpp b/Tests/core/test_measurementtype.cpp
new file mode 100644
index 0000000..452a5f1
--- /dev/null
+++ b/Tests/core/test_measurementtype.cpp
@@ -0,0 +1,48 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+namespace WPEFramework {
+namespace Tests {
+
+    TEST(Core_MeasurementType, simpleSet)
+    {
+        Core::MeasurementType<uint8_t> data;
+        data.Set(100);
+        data.Set(200);
+        data.Set(120);
+        data.Set(220);
+        data.Set(140);
+        data.Set(240);
+        EXPECT_EQ(data.Min(), 100u);
+        EXPECT_EQ(data.Max(), 240u);
+        EXPECT_EQ(data.Last(), 240u);
+        EXPECT_EQ(data.Average(), 170u);
+        EXPECT_EQ(data.Measurements(), 6u);
+        data.Reset();
+        EXPECT_EQ(data.Last(), 0u);
+        EXPECT_EQ(data.Average(), 0u);
+        EXPECT_EQ(data.Measurements(), 0u);
+    }
+} // Tests
+} // WPEFramework
diff --git b/Tests/core/test_messageException.cpp b/Tests/core/test_messageException.cpp
new file mode 100644
index 0000000..f36e362
--- /dev/null
+++ b/Tests/core/test_messageException.cpp
@@ -0,0 +1,39 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+TEST(test_messageException, simple_messageException)
+{
+    std::string msg = "Testing the message exception.";
+    MessageException exception(msg.c_str(),false);
+    EXPECT_STREQ(exception.Message(),msg.c_str());
+    
+    MessageException exception1(msg.c_str(),true);
+    char buffer[50];
+    string status = ": File exists";
+    snprintf(buffer, msg.size()+status.size()+1, "%s%s",msg.c_str(),status.c_str());
+    EXPECT_STREQ(exception1.Message(),buffer);
+}
diff --git b/Tests/core/test_networkinfo.cpp b/Tests/core/test_networkinfo.cpp
new file mode 100644
index 0000000..b7b82c6
--- /dev/null
+++ b/Tests/core/test_networkinfo.cpp
@@ -0,0 +1,111 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+TEST(test_ipv4addressiterator, simple_ipv4addressiterator)
+{
+   AdapterIterator adapters;
+   AdapterIterator adapter("eth0");
+   IPV4AddressIterator result;
+   
+   result.Next();
+   EXPECT_EQ(adapters.Index(),adapters.Index());
+   while (adapters.Next() == true) {
+       if (adapters.IsValid() == true) {
+           IPV4AddressIterator index(adapters.IPV4Addresses());
+           EXPECT_EQ(index.Count(),index.Count());
+           EXPECT_STREQ(adapters.Name().c_str(),adapters.Name().c_str());
+           while (index.Next() == true) {
+               NodeId current(index.Address());
+               IPNode currentNode(index.Address());
+               EXPECT_EQ(adapter.Add(currentNode),ERROR_NONE);
+               EXPECT_EQ(adapter.Gateway(currentNode,current),ERROR_NONE);
+               EXPECT_EQ(adapter.Delete(currentNode),ERROR_NONE);
+               EXPECT_EQ(adapter.Broadcast(current),ERROR_NONE);
+               if ((current.IsMulticast() == false) && (current.IsLocalInterface() == false)) {
+                   result = index;
+                   EXPECT_STREQ(current.HostName().c_str(),current.HostName().c_str());
+                   EXPECT_STREQ(current.HostAddress().c_str(),current.HostAddress().c_str());
+               }
+           }
+       }
+   }
+
+   IPV4AddressIterator ipv4addressiterator1;
+   ipv4addressiterator1 = result;
+   IPV4AddressIterator ipv4addressiterator2(result);
+   ipv4addressiterator1.Reset();
+}
+
+TEST(test_ipv6addressiterator, simple_ipv6addressiterator)
+{
+    AdapterIterator adapters;
+    IPV6AddressIterator result;
+    result.Next();
+    while (adapters.Next() == true) {
+        IPV6AddressIterator index(adapters.IPV6Addresses());
+        EXPECT_EQ(index.Count(),index.Count());
+        EXPECT_STREQ(adapters.Name().c_str(),adapters.Name().c_str());
+        while (index.Next() == true) {
+            NodeId current(index.Address());
+            if ((current.IsMulticast() == false) && (current.IsLocalInterface() == false)) {
+                result = index;
+                EXPECT_STREQ(current.HostName().c_str(),current.HostName().c_str());
+                EXPECT_STREQ(current.HostAddress().c_str(),current.HostAddress().c_str());
+            }
+        }
+    }
+    IPV6AddressIterator ipv6addressiterator1;
+    ipv6addressiterator1 = result;
+    IPV6AddressIterator ipv6addressiterator2(result);
+    ipv6addressiterator1.Reset();
+}
+
+TEST(test_adapteriterator, simple_adapteriterator)
+{
+    AdapterIterator adapter("eth0");
+    AdapterIterator adapter1 = adapter;
+    AdapterIterator adapter2(adapter);
+    AdapterIterator adapter3("test0");
+
+    EXPECT_TRUE(adapter.IsUp());
+    EXPECT_TRUE(adapter.IsRunning());
+    adapter.Up(true);
+    adapter.Up(false);
+
+    adapter.Flush();
+    EXPECT_EQ(adapter.Count(),adapter.Count());
+    EXPECT_STREQ(adapter.Name().c_str(),adapter.Name().c_str());
+
+    EXPECT_STREQ(adapter.MACAddress(':').c_str(),adapter.MACAddress(':').c_str());
+    uint8_t buffer[32];
+    adapter.MACAddress(buffer,32);
+}
+TEST(test_adapterobserver, simple_adapterobserver)
+{
+    AdapterObserver::INotification* callback;
+    AdapterObserver observer(callback);
+}
diff --git b/Tests/core/test_nodeid.cpp b/Tests/core/test_nodeid.cpp
new file mode 100644
index 0000000..7b8049d
--- /dev/null
+++ b/Tests/core/test_nodeid.cpp
@@ -0,0 +1,43 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+
+TEST(Core_NodeId, simpleSet)
+{
+   Core::NodeId nodeId("localhost:80");
+
+   std::cout << "Hostname:           " << nodeId.HostName() << std::endl;
+   std::cout << "Type:               " << nodeId.Type() << std::endl;
+   std::cout << "PortNumber:         " << nodeId.PortNumber() << std::endl;
+   std::cout << "IsValid:            " << nodeId.IsValid() << std::endl;
+   std::cout << "Size:               " << nodeId.Size() << std::endl;
+   std::cout << "HostAddress:        " << nodeId.HostAddress() << std::endl;
+   std::cout << "QualifiedName:      " << nodeId.QualifiedName() << std::endl;
+   std::cout << "IsLocalInterface:   " << nodeId.IsLocalInterface() << std::endl;
+   std::cout << "IsAnyInterface:     " << nodeId.IsAnyInterface() << std::endl;
+   std::cout << "IsMulticast:        " << nodeId.IsMulticast() << std::endl;
+   std::cout << "DefaultMask:        " << static_cast<int>(nodeId.DefaultMask()) << std::endl;
+}
+
diff --git b/Tests/core/test_numbertype.cpp b/Tests/core/test_numbertype.cpp
new file mode 100644
index 0000000..ac38a91
--- /dev/null
+++ b/Tests/core/test_numbertype.cpp
@@ -0,0 +1,250 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+namespace WPEFramework {
+namespace Tests {
+
+    template <typename T, bool NEGATIVE = false>
+    T Tester(string& text)
+    {
+        T num(text.c_str(), text.size());
+        EXPECT_EQ((NEGATIVE ? -90 : 90), num.Value());
+        EXPECT_TRUE(NEGATIVE == num.Negative());
+        return num;
+    }
+    
+    TEST(Core_NumberType, generic)
+    {
+        Core::NumberType<uint8_t> numbertype();
+        string buffer = "/Service/testing/numbertype";
+        Core::NumberType<Core::TextFragment> typetextfragment(Core::TextFragment(string(buffer)));
+
+        string valdata = "90";
+        Core::NumberType<uint8_t> val1 = Tester<Core::NumberType<uint8_t>>(valdata);
+        Core::NumberType<int8_t> val2 = Tester<Core::NumberType<int8_t>>(valdata);
+        EXPECT_EQ(Core::NumberType<uint8_t>::ToNetwork(val1),'Z');
+        EXPECT_EQ(Core::NumberType<uint8_t>::FromNetwork(val1),'Z');
+        EXPECT_EQ(Core::NumberType<int8_t>::ToNetwork(val2),'Z');
+        EXPECT_EQ(Core::NumberType<int8_t>::FromNetwork(val2),'Z');
+
+        Core::NumberType<int16_t> val3 = Tester<Core::NumberType<int16_t>>(valdata);
+        Core::NumberType<uint16_t> val4 = Tester<Core::NumberType<uint16_t>>(valdata);
+        EXPECT_EQ(Core::NumberType<int16_t>::ToNetwork(val3),23040);
+        EXPECT_EQ(Core::NumberType<int16_t>::FromNetwork(val3),23040);
+        EXPECT_EQ(Core::NumberType<uint16_t>::ToNetwork(val4),23040);
+        EXPECT_EQ(Core::NumberType<uint16_t>::FromNetwork(val4),23040);
+
+        Core::NumberType<int32_t> val5 = Tester<Core::NumberType<int32_t>>(valdata);
+        Core::NumberType<uint32_t> val6 = (unsigned)Tester<Core::NumberType<int32_t>>(valdata);
+        EXPECT_EQ(Core::NumberType<int32_t>::ToNetwork(val5),1509949440);
+        EXPECT_EQ(Core::NumberType<int32_t>::FromNetwork(val5),1509949440);
+        EXPECT_EQ(Core::NumberType<uint32_t>::ToNetwork(val6),1509949440u);
+        EXPECT_EQ(Core::NumberType<uint32_t>::FromNetwork(val6),1509949440u);
+
+        Core::NumberType<int64_t> val7 = Tester<Core::NumberType<int64_t>>(valdata);
+        Core::NumberType<uint64_t> val8 = (unsigned)Tester<Core::NumberType<int64_t>>(valdata);
+        EXPECT_EQ(Core::NumberType<int64_t>::ToNetwork(val7),90);
+        EXPECT_EQ(Core::NumberType<int64_t>::FromNetwork(val7),90);
+        EXPECT_EQ(Core::NumberType<uint64_t>::ToNetwork(val8),90u);
+        EXPECT_EQ(Core::NumberType<uint64_t>::FromNetwork(val8),90u);
+
+        val8.MaxSize();
+        EXPECT_EQ(val8.Serialize(valdata),2);
+        EXPECT_EQ(val8.Deserialize(valdata),2);
+        
+        string valdata1 = "90";
+        Core::NumberType<int8_t> num1 = Tester<Core::NumberType<int8_t>, false>(valdata);
+        Core::NumberType<int8_t> num2 = Tester<Core::NumberType<int8_t>, false>(valdata1);
+
+        EXPECT_TRUE(num1==num2);
+        EXPECT_FALSE(num1!=num2);
+        EXPECT_TRUE(num1<=num2);
+        EXPECT_TRUE(num1>=num2);
+        EXPECT_FALSE(num1<num2);
+        EXPECT_FALSE(num1>num2);
+     
+        EXPECT_STREQ((num1+num1).Text().c_str(),"-76");
+        EXPECT_STREQ((num1-num2).Text().c_str(),"0");
+        EXPECT_STREQ((num2*num1).Text().c_str(),"-92");
+        EXPECT_STREQ((num2/num1).Text().c_str(),"1");
+        num2/=num1;
+        EXPECT_STREQ(num2.Text().c_str(),"1");
+        num2-=num1;
+        EXPECT_STREQ(num2.Text().c_str(),"-89");
+        num1+=num1;
+        EXPECT_STREQ(num1.Text().c_str(),"-76");
+        num1*=num2;
+        EXPECT_STREQ(num1.Text().c_str(),"108");
+    }
+
+    TEST(Core_NumberType, PositiveNumber)
+    {
+        string data = "90";
+        Core::NumberType<uint8_t> num1 = Tester<Core::NumberType<uint8_t>>(data);
+        EXPECT_STREQ(num1.Text().c_str(), "90");
+        Core::NumberType<int8_t> num2 = Tester<Core::NumberType<int8_t>>(data);
+        EXPECT_STREQ(num2.Text().c_str(), "90");
+    }
+
+    TEST(Core_NumberType, NegativeNumber)
+    {
+        string data = "-90";
+        Core::NumberType<int8_t> num = Tester<Core::NumberType<int8_t>, true>(data);
+        EXPECT_STREQ(num.Text().c_str(), "-90");
+    }
+
+    TEST(Core_NumberType, NumberOutOfLimit)
+    {
+        string data = "256";
+        Core::NumberType<uint8_t> num1(data.c_str(), data.size());
+        EXPECT_NE(256, num1.Value());
+
+        data = "128";
+        Core::NumberType<int8_t> num2(data.c_str(), data.size());
+        EXPECT_NE(128, num2.Value());
+
+        data = "-129";
+        Core::NumberType<int8_t> num3(data.c_str(), data.size());
+        EXPECT_NE(-129, num3.Value());
+    }
+
+    TEST(Core_NumberType, PositiveHexNumber)
+    {
+        string data = "5A";
+        Core::NumberType<uint8_t, false, BASE_HEXADECIMAL> num1 = Tester<Core::NumberType<uint8_t, false, BASE_HEXADECIMAL>>(data);
+        EXPECT_STREQ(num1.Text().c_str(), "0x5A");
+        Core::NumberType<int8_t, true, BASE_HEXADECIMAL> num2 = Tester<Core::NumberType<int8_t, true, BASE_HEXADECIMAL>>(data);
+        EXPECT_STREQ(num2.Text().c_str(), "0x5A");
+
+        data = "0x5A";
+        Core::NumberType<uint8_t, false, BASE_HEXADECIMAL> num3 = Tester<Core::NumberType<uint8_t, false, BASE_HEXADECIMAL>>(data);
+        EXPECT_STREQ(num3.Text().c_str(), "0x5A");
+        Core::NumberType<int8_t, true, BASE_HEXADECIMAL> num4 = Tester<Core::NumberType<int8_t, true, BASE_HEXADECIMAL>>(data);
+        EXPECT_STREQ(num4.Text().c_str(), "0x5A");
+
+        Core::NumberType<uint8_t> num5 = Tester<Core::NumberType<uint8_t>>(data);
+        EXPECT_STREQ(num5.Text().c_str(), "90");
+        Core::NumberType<int8_t> num6 = Tester<Core::NumberType<int8_t>>(data);
+        EXPECT_STREQ(num6.Text().c_str(), "90");
+
+        Core::NumberType<int8_t, true, BASE_HEXADECIMAL> num7(num4);
+        Core::NumberType<int8_t, true, BASE_HEXADECIMAL> num8 = num4;
+    }
+
+    TEST(Core_NumberType, NegativeHexNumber)
+    {
+        string data = "-5A";
+        Core::NumberType<int8_t, true, BASE_HEXADECIMAL> num1 = Tester<Core::NumberType<int8_t, true, BASE_HEXADECIMAL>, true>(data);
+        EXPECT_STREQ(num1.Text().c_str(), "-0x5A");
+
+        data = "-0x5A";
+        Core::NumberType<int8_t, true, BASE_HEXADECIMAL> num2 = Tester<Core::NumberType<int8_t, true, BASE_HEXADECIMAL>, true>(data);
+        EXPECT_STREQ(num2.Text().c_str(), "-0x5A");
+
+        Core::NumberType<int8_t> num3 = Tester<Core::NumberType<int8_t>, true>(data);
+        EXPECT_STREQ(num3.Text().c_str(), "-90");
+    }
+
+    TEST(Core_NumberType, PositiveOctNumber)
+    {
+        string data = "132";
+        Core::NumberType<uint8_t, false, BASE_OCTAL> num1 = Tester<Core::NumberType<uint8_t, false, BASE_OCTAL>>(data);
+        EXPECT_STREQ(num1.Text().c_str(), "0132");
+        Core::NumberType<int8_t, true, BASE_OCTAL> num2 = Tester<Core::NumberType<int8_t, true, BASE_OCTAL>>(data);
+        EXPECT_STREQ(num2.Text().c_str(), "0132");
+
+        data = "0132";
+        Core::NumberType<uint8_t, false, BASE_OCTAL> num3 = Tester<Core::NumberType<uint8_t, false, BASE_OCTAL>>(data);
+        EXPECT_STREQ(num3.Text().c_str(), "0132");
+        Core::NumberType<int8_t, true, BASE_OCTAL> num4 = Tester<Core::NumberType<int8_t, true, BASE_OCTAL>>(data);
+        EXPECT_STREQ(num4.Text().c_str(), "0132");
+
+        Core::NumberType<uint8_t> num5 = Tester<Core::NumberType<uint8_t>>(data);
+        EXPECT_STREQ(num5.Text().c_str(), "90");
+        Core::NumberType<int8_t> num6 = Tester<Core::NumberType<int8_t>>(data);
+        EXPECT_STREQ(num6.Text().c_str(), "90");
+    }
+
+    TEST(Core_NumberType, NegativeOctNumber)
+    {
+        string data = "-132";
+        Core::NumberType<int8_t, true, BASE_OCTAL> num1 = Tester<Core::NumberType<int8_t, true, BASE_OCTAL>, true>(data);
+        EXPECT_STREQ(num1.Text().c_str(), "-0132");
+
+        data = "-0132";
+        Core::NumberType<int8_t, true, BASE_OCTAL> num2 = Tester<Core::NumberType<int8_t, true, BASE_OCTAL>, true>(data);
+        EXPECT_STREQ(num2.Text().c_str(), "-0132");
+
+        Core::NumberType<int8_t> num3 = Tester<Core::NumberType<int8_t>, true>(data);
+        EXPECT_STREQ(num3.Text().c_str(), "-90");
+    }
+
+    TEST(Core_NumberType, ConversionFunctions)
+    {
+        EXPECT_EQ(Core::FromDigits('a'), 0);
+        EXPECT_EQ(Core::FromDigits('1'), 1);
+
+        EXPECT_EQ(Core::FromHexDigits('1'), 1);
+        EXPECT_EQ(Core::FromHexDigits('a'), 10);
+        EXPECT_EQ(Core::FromHexDigits('A'), 10);
+        EXPECT_EQ(Core::FromHexDigits('z'), 0);
+
+        EXPECT_EQ(Core::FromBase64('1'), 53);
+        EXPECT_EQ(Core::FromBase64('a'), 26);
+        EXPECT_EQ(Core::FromBase64('A'), 0);
+        EXPECT_EQ(Core::FromBase64('+'), 62);
+        EXPECT_EQ(Core::FromBase64('/'), 63);
+        EXPECT_EQ(Core::FromBase64('-'), 0);
+
+        EXPECT_EQ(Core::FromDirect('a'), 97);
+        EXPECT_EQ(Core::ToDigits(9), '9');
+
+        EXPECT_EQ(Core::ToHexDigits(1), '1');
+        EXPECT_EQ(Core::ToHexDigits(10), 'A');
+        EXPECT_EQ(Core::ToHexDigits(30), '0');
+
+        EXPECT_EQ(Core::ToBase64(26), 'a');
+        EXPECT_EQ(Core::ToDirect(97), 'a');
+    }
+    TEST(Core_NumberType, Fractional_test)
+    {
+        Core::Fractional fractional();
+        Core::Fractional fractional1(3,2);
+        Core::Fractional fractional2(fractional1);
+        Core::Fractional fractional3;
+        fractional3 = fractional1;
+        EXPECT_EQ(fractional1.Integer(),3);
+        EXPECT_EQ(fractional1.Remainder(),2u);
+
+        Core::NumberType<Core::Fractional, true> num1;
+        fractional3 = num1.Max();
+
+        EXPECT_EQ(fractional3.Integer(),2147483647);
+        EXPECT_EQ(fractional3.Remainder(),4294967295);
+        fractional3 = num1.Min();
+        EXPECT_EQ(fractional3.Integer(),-2147483648);
+        EXPECT_EQ(fractional3.Remainder(),4294967295);
+    }
+} // Tests
+} // WPEFramework
diff --git b/Tests/core/test_optional.cpp b/Tests/core/test_optional.cpp
new file mode 100644
index 0000000..1b9bf97
--- /dev/null
+++ b/Tests/core/test_optional.cpp
@@ -0,0 +1,51 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+TEST(test_optional, simple_test)
+{
+    OptionalType<int> obj;
+    int type = obj;
+    EXPECT_EQ(type, 0);
+    obj.Clear();
+    EXPECT_FALSE(obj.IsSet());
+    OptionalType<string> obj1("request");
+    OptionalType<string> obj2(obj1);
+    EXPECT_TRUE(obj2 == obj1);
+    EXPECT_TRUE(obj2.Value() == obj1.Value());
+    EXPECT_TRUE(obj1.IsSet());
+    const OptionalType<string> obj3;
+    OptionalType<string> obj4;
+    obj4 = obj3;
+    const OptionalType<int> obj5;
+    const OptionalType<int> objSample = 40;
+    OptionalType<int> object;
+    object = 20;
+    EXPECT_TRUE(objSample != object.Value());
+    EXPECT_TRUE(objSample != obj5);
+    int type1 = objSample;
+    EXPECT_EQ(type1, 40);
+}
diff --git b/Tests/core/test_parser.cpp b/Tests/core/test_parser.cpp
new file mode 100644
index 0000000..e3cd8e5
--- /dev/null
+++ b/Tests/core/test_parser.cpp
@@ -0,0 +1,88 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+class Deserializer {
+private:
+    typedef ParserType<TerminatorCarriageReturnLineFeed, Deserializer> Parser;
+
+public :
+    Deserializer()
+       : _parser(*this)
+    {
+    }
+
+    void operations()
+    {
+        _parser.Reset();
+        _parser.CollectWord();
+        _parser.CollectWord('/');
+        _parser.CollectWord(Core::ParserType<TerminatorCarriageReturnLineFeed, Deserializer>::ParseState::UPPERCASE);
+        _parser.CollectWord('/',Core::ParserType<TerminatorCarriageReturnLineFeed, Deserializer>::ParseState::UPPERCASE);
+        _parser.CollectLine();
+        _parser.CollectLine(Core::ParserType<TerminatorCarriageReturnLineFeed, Deserializer>::ParseState::UPPERCASE);
+        _parser.FlushLine();
+        _parser.PassThrough(5);
+    }
+
+    ~Deserializer()
+    {
+    }
+
+private:
+    Parser _parser;
+};
+
+TEST(test_parser_type, simple_parser_type)
+{
+    Deserializer deserializer;
+    deserializer.operations();
+}
+
+TEST(test_text_parser, simple_text_parser)
+{
+    TextFragment inputLine("/Service/testing/parsertest");
+    TextParser textparser(inputLine);
+    textparser.Skip(2);
+    textparser.Skip('S');
+    textparser.Find(_T("e"));
+    textparser.SkipWhiteSpace();
+    textparser.SkipLine();
+    OptionalType<TextFragment> token;
+    textparser.ReadText(token, _T("/"));
+}
+
+TEST(test_path_parser, simple_path_parser)
+{
+    TextFragment inputFile("C://Service/testing/pathparsertest.txt");
+    PathParser pathparser(inputFile);
+    
+    EXPECT_EQ(pathparser.Drive().Value(),'C');
+    EXPECT_STREQ(pathparser.Path().Value().Text().c_str(),_T("//Service/testing"));
+    EXPECT_STREQ(pathparser.FileName().Value().Text().c_str(),_T("pathparsertest.txt"));
+    EXPECT_STREQ(pathparser.BaseFileName().Value().Text().c_str(),_T("pathparsertest"));
+    EXPECT_STREQ(pathparser.Extension().Value().Text().c_str(),_T("txt"));;
+}
diff --git b/Tests/core/test_portability.cpp b/Tests/core/test_portability.cpp
new file mode 100644
index 0000000..587fa05
--- /dev/null
+++ b/Tests/core/test_portability.cpp
@@ -0,0 +1,112 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+#include <thread>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+class ThreadClass : public Core::Thread {
+public:
+    ThreadClass() = delete;
+    ThreadClass(const ThreadClass&) = delete;
+    ThreadClass& operator=(const ThreadClass&) = delete;
+
+    ThreadClass(std::thread::id parentId)
+        : Core::Thread(Core::Thread::DefaultStackSize(), _T("Test"))
+        , _threadDone(false)
+        , _parentId(parentId)
+    {
+    }
+
+    virtual ~ThreadClass()
+    {
+    }
+
+    virtual uint32_t Worker() override
+    {
+        while (IsRunning() && (!_threadDone)) {
+            EXPECT_TRUE(_parentId != std::this_thread::get_id());
+            _threadDone = true;
+            ::SleepMs(50);
+        }
+        return (Core::infinite);
+    }
+
+private:
+    volatile bool _threadDone;
+    std::thread::id _parentId;
+};
+
+TEST(test_portability, simple_upper)
+{
+    std::string input = "hello";
+    std::string output;
+    ToUpper(input,output);
+    EXPECT_STREQ(output.c_str(),_T("HELLO"));
+
+    ToUpper(input);
+    EXPECT_STREQ(input.c_str(),_T("HELLO"));
+}
+
+TEST(test_portability, simple_lower)
+{
+    std::string input = "HELLO";
+    std::string output;
+    ToLower(input,output);
+    EXPECT_STREQ(output.c_str(),_T("hello"));
+    
+    ToLower(input);
+    EXPECT_STREQ(input.c_str(),_T("hello"));
+}
+
+TEST(test_portability, simple_generic)
+{
+   SleepS(1);
+   SleepMs(1);
+   EXPECT_EQ(htonll(12345),ntohll(12345));
+   DumpCallStack();
+
+   std::thread::id parentId;
+   ThreadClass object(parentId);
+   object.Run();
+
+   DumpCallStack(object.Id());  
+   object.Stop();
+   
+   std::string s1 = "Hello";
+   uint8_t dest_buffer[5];
+   memrcpy((void*)dest_buffer,(void*)s1.c_str(),  static_cast<size_t>(5));
+   EXPECT_STREQ((const char*)(dest_buffer),s1.c_str());
+}
+
+TEST(test_error, simple_error)
+{
+   EXPECT_STREQ(ErrorToString(ERROR_NONE),"ERROR_NONE");
+}
+
+TEST(test_void, simple_void)
+{
+    Void v;
+    Void v2 = v;
+}
diff --git b/Tests/core/test_processinfo.cpp b/Tests/core/test_processinfo.cpp
new file mode 100644
index 0000000..587b6ba
--- /dev/null
+++ b/Tests/core/test_processinfo.cpp
@@ -0,0 +1,49 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+
+TEST(Core_ProcessInfo, simpleSet)
+{
+    pid_t pid = getpid();
+    Core::ProcessInfo processInfo(pid);
+    std::cout << "Name           :" << processInfo.Name() << std::endl;
+    std::cout << "Id             :" << processInfo.Id() << std::endl;
+    std::cout << "Priority       :" << static_cast<int>(processInfo.Priority()) << std::endl;
+    std::cout << "IsActive       :" << (processInfo.IsActive() ? "Yes" : "No") << std::endl;
+    std::cout << "Executable     :" << processInfo.Executable() << std::endl;
+    std::cout << "Group          :" << processInfo.Group() << std::endl;
+    std::cout << "User           :" << processInfo.User() << std::endl;
+    std::cout << "Size Allocated :" << (processInfo.Allocated() >> 10) << " KB" << std::endl;
+    std::cout << "Size Resident  :" << (processInfo.Resident() >> 10) << " KB" << std::endl;
+    std::cout << "Size Shared    :" << (processInfo.Shared() >> 10) << " KB" << std::endl;
+
+    Core::ProcessInfo::Iterator childIterator = processInfo.Children();
+
+    std::cout << "Children (" << childIterator.Count() << ") " << std::endl;
+    while (childIterator.Next()) {
+        Core::ProcessInfo childProcessInfo = childIterator.Current();
+        std::cout << "\tName        : " << childProcessInfo.Name() << " (" << childProcessInfo.Id() << "): " << childProcessInfo.Resident() << std::endl;
+    }
+}
diff --git b/Tests/core/test_queue.cpp b/Tests/core/test_queue.cpp
new file mode 100644
index 0000000..0b4e563
--- /dev/null
+++ b/Tests/core/test_queue.cpp
@@ -0,0 +1,42 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+
+TEST(test_queue, simple_queue)
+{
+    QueueType<int> obj1(20);
+    EXPECT_TRUE(obj1.Insert(20,300));
+    EXPECT_TRUE(obj1.Insert(30,300));
+    EXPECT_TRUE(obj1.Post(20));
+    EXPECT_TRUE(obj1.Remove(20));
+    int a_Result = 30;
+    EXPECT_TRUE(obj1.Extract(a_Result,300));
+    EXPECT_EQ(obj1.Length(),1u);
+    obj1.Enable();
+    obj1.Disable();
+    obj1.Flush();
+}
diff --git b/Tests/core/test_rangetype.cpp b/Tests/core/test_rangetype.cpp
new file mode 100644
index 0000000..fd9a3cb
--- /dev/null
+++ b/Tests/core/test_rangetype.cpp
@@ -0,0 +1,66 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+namespace WPEFramework {
+namespace Tests {
+
+    template <typename T, bool BOUNDARY_INCLUSIVE = true>
+    void RangeTest(T data)
+    {
+        EXPECT_TRUE(data.IsValid());
+        EXPECT_EQ(data.Maximum(), 100u);
+        EXPECT_EQ(data.Minimum(), 1u);
+        if (BOUNDARY_INCLUSIVE) {
+            EXPECT_EQ(data.Range(), 100u);
+            EXPECT_TRUE(data.InRange(1));
+            EXPECT_TRUE(data.InRange(100));
+        } else {
+            EXPECT_EQ(data.Range(), 98u);
+            EXPECT_FALSE(data.InRange(1));
+            EXPECT_FALSE(data.InRange(100));
+        }
+    }
+
+    TEST(Core_RangeType, BoundaryExclusive)
+    {
+        Core::RangeType<uint8_t, false, false> data(1u, 100u);
+        RangeTest<Core::RangeType<uint8_t, false, false>, false>(data);
+    }
+
+    TEST(Core_RangeType, BoundaryInclusive)
+    {
+        Core::RangeType<uint8_t, true, true> data(1u, 100u);
+        RangeTest<Core::RangeType<uint8_t, true, true>>(data);
+    }
+
+    TEST(Core_RangeType, EqualBoundary)
+    {
+        Core::RangeType<uint8_t, true, true> withBoundary(2u, 2u);
+        EXPECT_EQ(withBoundary.Range(), 1u);
+
+        Core::RangeType<uint8_t, false, false> withoutBoundary(2u, 2u);
+        EXPECT_EQ(withoutBoundary.Range(), 0u);
+    }
+} // Tests
+} // WPEFramework
diff --git b/Tests/core/test_readwritelock.cpp b/Tests/core/test_readwritelock.cpp
new file mode 100644
index 0000000..d3fbabb
--- /dev/null
+++ b/Tests/core/test_readwritelock.cpp
@@ -0,0 +1,39 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+TEST(test_ReadWritelock, simpleSet)
+{
+    ReadWriteLock readObj;
+    EXPECT_TRUE(readObj.ReadLock());
+
+    readObj.ReadUnlock();
+    ReadWriteLock writeObj;
+    EXPECT_TRUE(writeObj.WriteLock());
+
+    writeObj.WriteUnlock();
+}
+
diff --git b/Tests/core/test_rectangle.cpp b/Tests/core/test_rectangle.cpp
new file mode 100644
index 0000000..2c5b1d7
--- /dev/null
+++ b/Tests/core/test_rectangle.cpp
@@ -0,0 +1,53 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+TEST(test_rectangle, simple_rectangle)
+{
+    Rectangle();
+    Rectangle r1(2,3,2,3); 
+    Rectangle r2(2,4,2,4);
+    EXPECT_FALSE(r1 == r2);
+    EXPECT_TRUE(r1 != r2);
+ 
+    Rectangle r3(2,3,2,3); 
+    EXPECT_TRUE(r1 == r3);
+    EXPECT_FALSE(r1 != r3);
+     
+    Rectangle r4 = r1 & r2;
+    Rectangle r5(2,4,2,2);
+    EXPECT_TRUE(r4 == r5);
+
+    Rectangle r6 = r1 | r2;
+    Rectangle r7(2,3,2,5);
+    EXPECT_TRUE(r6 == r7);
+    
+    Rectangle r8 = r1.combine(r2);
+    EXPECT_TRUE(r8 == r7);
+
+    EXPECT_TRUE(r1.Contains(2,3));
+    EXPECT_TRUE(r1.Overlaps(r2));
+}
diff --git a/Tests/core/test_rpc.cpp b/Tests/core/test_rpc.cpp
index 53a2173..6d14c01 100644
--- a/Tests/core/test_rpc.cpp
+++ b/Tests/core/test_rpc.cpp
@@ -25,8 +25,6 @@
 #include <com/com.h>
 #include <core/Portability.h>
 
-static string g_connectorName = _T("/tmp/wperpc01");
-
 namespace WPEFramework {
 namespace Exchange {
     struct IAdder : virtual public Core::IUnknown {
@@ -35,45 +33,42 @@ namespace Exchange {
         virtual void Add(uint32_t value) = 0;
         virtual uint32_t GetPid() = 0;
     };
-}
-}
+} // Exchange
 
-using namespace WPEFramework;
-using namespace std;
+namespace Tests {
 
-class Adder : public Exchange::IAdder
-{
-public:
-    Adder()
-        : m_value(0)
+    class Adder : public Exchange::IAdder
     {
-    }
+    public:
+        Adder()
+            : m_value(0)
+        {
+        }
 
-    uint32_t GetValue()
-    {
-        return m_value;
-    }
+        uint32_t GetValue()
+        {
+            return m_value;
+        }
 
-    void Add(uint32_t value)
-    {
-        m_value += value;
-    }
+        void Add(uint32_t value)
+        {
+            m_value += value;
+        }
 
-    uint32_t GetPid()
-    {
-        return getpid();
-    }
+        uint32_t GetPid()
+        {
+            return getpid();
+        }
 
-    BEGIN_INTERFACE_MAP(Adder)
-        INTERFACE_ENTRY(Exchange::IAdder)
-    END_INTERFACE_MAP
+        BEGIN_INTERFACE_MAP(Adder)
+            INTERFACE_ENTRY(Exchange::IAdder)
+        END_INTERFACE_MAP
 
-private:
-    uint32_t m_value;
-};
+    private:
+        uint32_t m_value;
+    };
 
-// Proxystubs.
-namespace WPEFramework {
+    // Proxystubs.
     using namespace Exchange;
 
     // -----------------------------------------------------------------
@@ -96,7 +91,7 @@ namespace WPEFramework {
             RPC::Data::Input& input(message->Parameters());
 
             // call implementation
-            IAdder* implementation = input.Implementation<IAdder>();
+            IAdder* implementation = reinterpret_cast<IAdder*>(input.Implementation());
             ASSERT((implementation != nullptr) && "Null IAdder implementation pointer");
             const uint32_t output = implementation->GetValue();
 
@@ -115,7 +110,7 @@ namespace WPEFramework {
             const uint32_t param0 = reader.Number<uint32_t>();
 
             // call implementation
-            IAdder* implementation = input.Implementation<IAdder>();
+            IAdder* implementation = reinterpret_cast<IAdder*>(input.Implementation());
             ASSERT((implementation != nullptr) && "Null IAdder implementation pointer");
             implementation->Add(param0);
         },
@@ -126,7 +121,7 @@ namespace WPEFramework {
             RPC::Data::Input& input(message->Parameters());
 
             // call implementation
-            IAdder* implementation = input.Implementation<IAdder>();
+            IAdder* implementation = reinterpret_cast<IAdder*>(input.Implementation());
             ASSERT((implementation != nullptr) && "Null IAdder implementation pointer");
             const uint32_t output = implementation->GetPid();
 
@@ -153,7 +148,7 @@ namespace WPEFramework {
 
     class AdderProxy final : public ProxyStub::UnknownProxyType<IAdder> {
     public:
-        AdderProxy(const Core::ProxyType<Core::IPCChannel>& channel, void* implementation, const bool otherSideInformed)
+        AdderProxy(const Core::ProxyType<Core::IPCChannel>& channel, RPC::instance_id implementation, const bool otherSideInformed)
             : BaseClass(channel, implementation, otherSideInformed)
         {
         }
@@ -218,90 +213,93 @@ namespace WPEFramework {
         } ProxyStubRegistration;
 
     } // namespace
-}
-
-namespace {
-class ExternalAccess : public RPC::Communicator
-{
-private:
-    ExternalAccess() = delete;
-    ExternalAccess(const ExternalAccess &) = delete;
-    ExternalAccess & operator=(const ExternalAccess &) = delete;
-
-public:
-    ExternalAccess(const Core::NodeId & source)
-        : RPC::Communicator(source, _T(""))
-    {
-        Open(Core::infinite);
-    }
 
-    ~ExternalAccess()
-    {
-        Close(Core::infinite);
-    }
+    namespace {
+        class ExternalAccess : public RPC::Communicator
+        {
+        public:
+            ExternalAccess() = delete;
+            ExternalAccess(const ExternalAccess &) = delete;
+            ExternalAccess & operator=(const ExternalAccess &) = delete;
 
-private:
-    virtual void* Aquire(const string& className, const uint32_t interfaceId, const uint32_t versionId)
-    {
-        void* result = nullptr;
+            ExternalAccess(const Core::NodeId & source)
+                : RPC::Communicator(source, _T(""))
+            {
+                Open(Core::infinite);
+            }
 
-        if (interfaceId == Exchange::IAdder::ID) {
-            Exchange::IAdder * newAdder = Core::Service<Adder>::Create<Exchange::IAdder>();
-            result = newAdder;
-        }
+            ~ExternalAccess()
+            {
+                Close(Core::infinite);
+            }
+
+        private:
+            virtual void* Aquire(const string& className, const uint32_t interfaceId, const uint32_t versionId)
+            {
+                void* result = nullptr;
+
+                if (interfaceId == Exchange::IAdder::ID) {
+                    Exchange::IAdder * newAdder = Core::Service<Adder>::Create<Exchange::IAdder>();
+                    result = newAdder;
+                }
 
-        return result;
+                return result;
+            }
+        };
     }
-};
-}
 
-TEST(Core_RPC, adder)
-{
-   IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator & testAdmin) {
-      Core::NodeId remoteNode(g_connectorName.c_str());
+    TEST(Core_RPC, adder)
+    {
+       std::string connector{"/tmp/wperpc01"};
+       auto lambdaFunc = [connector](IPTestAdministrator & testAdmin) {
+          Core::NodeId remoteNode(connector.c_str());
+
+          ExternalAccess communicator(remoteNode);
 
-      ExternalAccess communicator(remoteNode);
+          testAdmin.Sync("setup server");
 
-      testAdmin.Sync("setup server");
+          testAdmin.Sync("done testing");
 
-      testAdmin.Sync("done testing");
+          communicator.Close(Core::infinite);
+       };
 
-      communicator.Close(Core::infinite);
-   };
+       static std::function<void (IPTestAdministrator&)> lambdaVar = lambdaFunc;
 
-   IPTestAdministrator testAdmin(otherSide);
+       IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin ) { lambdaVar(testAdmin); };
 
-   testAdmin.Sync("setup server");
+       IPTestAdministrator testAdmin(otherSide);
 
-   {
-      Core::NodeId remoteNode(g_connectorName.c_str());
+       testAdmin.Sync("setup server");
 
-      Core::ProxyType<RPC::InvokeServerType<4, 1>> engine(Core::ProxyType<RPC::InvokeServerType<4, 1>>::Create(Core::Thread::DefaultStackSize()));
-      Core::ProxyType<RPC::CommunicatorClient> client(
-           Core::ProxyType<RPC::CommunicatorClient>::Create(
-               remoteNode,
-               Core::ProxyType<Core::IIPCServer>(engine)
-           ));
-      engine->Announcements(client->Announcement());
+       {
+          Core::NodeId remoteNode(connector.c_str());
 
-      // Create remote instance of "IAdder".
-      Exchange::IAdder * adder = client->Open<Exchange::IAdder>(_T("Adder"));
+          Core::ProxyType<RPC::InvokeServerType<4, 0, 1>> engine = Core::ProxyType<RPC::InvokeServerType<4, 0, 1>>::Create();
+          ASSERT(engine != nullptr);
+          Core::ProxyType<RPC::CommunicatorClient> client = Core::ProxyType<RPC::CommunicatorClient>::Create(remoteNode, Core::ProxyType<Core::IIPCServer>(engine));
+          ASSERT(client != nullptr);
+          engine->Announcements(client->Announcement());
 
-      // Perform some arithmatic.
-      EXPECT_EQ(adder->GetValue(), static_cast<uint32_t>(0));
-      adder->Add(20);
-      EXPECT_EQ(adder->GetValue(), static_cast<uint32_t>(20));
-      adder->Add(22);
-      EXPECT_EQ(adder->GetValue(), static_cast<uint32_t>(42));
+          // Create remote instance of "IAdder".
+          Exchange::IAdder * adder = client->Open<Exchange::IAdder>(_T("Adder"));
 
-      // Make sure other side is indeed running in other process.
-      EXPECT_NE(adder->GetPid(), getpid());
+          // Perform some arithmatic.
+          EXPECT_EQ(adder->GetValue(), static_cast<uint32_t>(0));
+          adder->Add(20);
+          EXPECT_EQ(adder->GetValue(), static_cast<uint32_t>(20));
+          adder->Add(22);
+          EXPECT_EQ(adder->GetValue(), static_cast<uint32_t>(42));
 
-      adder->Release();
+          // Make sure other side is indeed running in other process.
+          EXPECT_NE(adder->GetPid(), (uint32_t)getpid());
 
-      client->Close(Core::infinite);
-   }
+          adder->Release();
 
-   testAdmin.Sync("done testing");
-   Core::Singleton::Dispose();
-}
+          client->Close(Core::infinite);
+       }
+
+       testAdmin.Sync("done testing");
+       Core::Singleton::Dispose();
+    }
+} // Tests
+} // WPEFramework
diff --git b/Tests/core/test_semaphore.cpp b/Tests/core/test_semaphore.cpp
new file mode 100644
index 0000000..410909c
--- /dev/null
+++ b/Tests/core/test_semaphore.cpp
@@ -0,0 +1,137 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+#include <thread>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+static int g_shared = 1;
+
+class ThreadClass : public Core::Thread {
+public:
+    ThreadClass() = delete;
+    ThreadClass(const ThreadClass&) = delete;
+    ThreadClass& operator=(const ThreadClass&) = delete;
+
+    ThreadClass(Core::CriticalSection& lock,std::thread::id parentId)
+        : Core::Thread(Core::Thread::DefaultStackSize(), _T("Test"))
+        , _lock(lock)
+        , _parentId(parentId)
+        , _done(false)
+    {
+    }
+
+    virtual ~ThreadClass()
+    {
+    }
+
+    virtual uint32_t Worker() override
+    {
+        while (IsRunning() && (!_done)) {
+            EXPECT_TRUE(_parentId != std::this_thread::get_id());
+            _done = true;
+            _lock.Lock();
+            g_shared++;
+            _lock.Unlock();
+            ::SleepMs(50);
+        }
+        return (Core::infinite);
+    }
+
+private:
+    Core::CriticalSection& _lock;
+    std::thread::id _parentId;
+    volatile bool _done;
+};
+
+
+TEST(test_criticalsection, simple_criticalsection)
+{
+    Core::CriticalSection lock;
+    std::thread::id parentId;
+
+    ThreadClass object(lock,parentId);
+    object.Run();
+    lock.Lock();
+    g_shared++;
+    lock.Unlock();
+    object.Stop();
+    EXPECT_EQ(g_shared,2);
+}
+TEST(test_binairysemaphore, simple_binairysemaphore_timeout)
+{
+    BinairySemaphore bsem(true);
+    uint64_t timeOut(Core::Time::Now().Add(3).Ticks());
+    uint64_t now(Core::Time::Now().Ticks());
+    do
+    {
+        if (now < timeOut) {
+            bsem.Lock(static_cast<uint32_t>((timeOut - now) / Core::Time::TicksPerMillisecond));
+            g_shared++;
+        }
+    } while (timeOut < Core::Time::Now().Ticks());
+    EXPECT_EQ(g_shared,3);
+}
+
+TEST(test_binairysemaphore, simple_binairysemaphore)
+{
+    BinairySemaphore bsem(1,5);
+    bsem.Lock();
+    g_shared++;
+    bsem.Unlock();
+    EXPECT_EQ(g_shared,4);
+}
+TEST(test_countingsemaphore, simple_countingsemaphore_timeout)
+{
+    CountingSemaphore csem(1,5);
+    uint64_t timeOut(Core::Time::Now().Add(3).Ticks());
+    uint64_t now(Core::Time::Now().Ticks());
+    do
+    {
+        if (now < timeOut) {
+            csem.Lock(static_cast<uint32_t>((timeOut - now) / Core::Time::TicksPerMillisecond));
+            g_shared++;
+        }
+    } while (timeOut < Core::Time::Now().Ticks());
+    EXPECT_EQ(g_shared,5);
+   
+    timeOut = Core::Time::Now().Add(3).Ticks();
+    now = Core::Time::Now().Ticks();
+    do
+    {
+        if (now < timeOut) {
+            csem.TryUnlock(static_cast<uint32_t>((timeOut - now) / Core::Time::TicksPerMillisecond));
+            g_shared++;
+        }
+    } while (timeOut < Core::Time::Now().Ticks());
+    EXPECT_EQ(g_shared,6);
+}
+TEST(test_countingsemaphore, simple_countingsemaphore)
+{
+    CountingSemaphore csem(1,5);
+    csem.Lock();
+    g_shared++;
+    csem.Unlock(1);
+    EXPECT_EQ(g_shared,7);
+}
diff --git a/Tests/core/test_sharedbuffer.cpp b/Tests/core/test_sharedbuffer.cpp
index f345062..fa8cbb3 100644
--- a/Tests/core/test_sharedbuffer.cpp
+++ b/Tests/core/test_sharedbuffer.cpp
@@ -25,87 +25,91 @@
 namespace WPEFramework {
 namespace Tests {
 
-const uint32_t g_bufferSize = 8 * 1024;
-const uint16_t g_administrationSize = 64;
-const char g_bufferName[] = "testbuffer01";
-
-void CleanUpBuffer()
-{
-   // TODO: shouldn't this be done producer-side?
-   char systemCmd[1024];
-   sprintf(systemCmd, "rm -f %s", g_bufferName);
-   system(systemCmd);
-   sprintf(systemCmd, "rm -f %s.admin", g_bufferName);
-   system(systemCmd);
-}
-
-TEST(Core_SharedBuffer, simpleSet)
-{
-   IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator & testAdmin) {
-       CleanUpBuffer();
-
-       uint32_t result;
-       Core::SharedBuffer buff01(g_bufferName,
-           Core::File::USER_READ    |
-           Core::File::USER_WRITE   |
-           Core::File::USER_EXECUTE |
-           Core::File::GROUP_READ   |
-           Core::File::GROUP_WRITE  |
-           Core::File::OTHERS_READ  |
-           Core::File::OTHERS_WRITE,
-           g_bufferSize,
-           g_administrationSize);
-       result = buff01.RequestProduce(Core::infinite);
-       EXPECT_EQ(result, Core::ERROR_NONE);
-
-       testAdmin.Sync("setup producer");
-
-       testAdmin.Sync("setup consumer");
-
-       uint8_t * buffer = buff01.Buffer();
-       uint64_t bufferSize = buff01.Size();
-       EXPECT_EQ(bufferSize, g_bufferSize);
-
-       buffer[0] = 42;
-       buffer[1] = 43;
-       buffer[2] = 44;
-
-       result = buff01.Produced();
-       EXPECT_EQ(result, Core::ERROR_NONE);
-
-       testAdmin.Sync("consumer done");
-   };
-
-   // This side (tested) acts as client (consumer).
-   IPTestAdministrator testAdmin(otherSide);
-
-   {
-       // In extra scope, to make sure "buff01" is destructed before producer.
-       testAdmin.Sync("setup producer");
-
-       uint32_t result;
-       Core::SharedBuffer buff01(g_bufferName);
-
-       testAdmin.Sync("setup consumer");
-
-       result = buff01.RequestConsume(Core::infinite);
-       EXPECT_EQ(result, Core::ERROR_NONE);
-
-       uint8_t * buffer = buff01.Buffer();
-       uint64_t bufferSize = buff01.Size();
-       EXPECT_EQ(bufferSize, g_bufferSize);
-
-       EXPECT_EQ(buffer[0], 42);
-       EXPECT_EQ(buffer[1], 43);
-       EXPECT_EQ(buffer[2], 44);
-
-       buff01.Consumed();
-       EXPECT_EQ(result, Core::ERROR_NONE);
-   }
-
-   testAdmin.Sync("consumer done");
-
-   Core::Singleton::Dispose();
-}
-}
-}
+    void CleanUpBuffer(string bufferName)
+    {
+       // TODO: shouldn't this be done producer-side?
+       char systemCmd[1024];
+       string command = "rm -f ";
+       snprintf(systemCmd, command.size()+bufferName.size()+1, "%s%s", command.c_str(),bufferName.c_str());
+       system(systemCmd);
+       string ext = ".admin";
+       snprintf(systemCmd, command.size()+bufferName.size()+ext.size()+1, "%s%s%s", command.c_str(),bufferName.c_str(),ext.c_str());
+       system(systemCmd);
+    }
+
+    TEST(Core_SharedBuffer, simpleSet)
+    {
+        std::string bufferName {"testbuffer01"} ;
+        auto lambdaFunc = [bufferName](IPTestAdministrator & testAdmin) {
+            CleanUpBuffer(bufferName);
+
+            uint16_t administrationSize = 64;
+            uint32_t bufferSize = 8 * 1024;
+            uint32_t result;
+
+            Core::SharedBuffer buff01(bufferName.c_str(),
+               Core::File::USER_READ    |
+               Core::File::USER_WRITE   |
+               Core::File::USER_EXECUTE |
+               Core::File::GROUP_READ   |
+               Core::File::GROUP_WRITE  |
+               Core::File::OTHERS_READ  |
+               Core::File::OTHERS_WRITE,
+               bufferSize,
+               administrationSize);
+            result = buff01.RequestProduce(Core::infinite);
+            EXPECT_EQ(result, Core::ERROR_NONE);
+
+            testAdmin.Sync("setup producer");
+
+            testAdmin.Sync("setup consumer");
+
+            uint8_t * buffer = buff01.Buffer();
+            EXPECT_EQ(buff01.Size(), bufferSize);
+
+            buffer[0] = 42;
+            buffer[1] = 43;
+            buffer[2] = 44;
+
+            result = buff01.Produced();
+            EXPECT_EQ(result, Core::ERROR_NONE);
+
+            testAdmin.Sync("consumer done");
+        };
+
+        static std::function<void (IPTestAdministrator&)> lambdaVar = lambdaFunc;
+
+        IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin ) { lambdaVar(testAdmin); };
+
+        // This side (tested) acts as client (consumer).
+        IPTestAdministrator testAdmin(otherSide);
+        {
+            // In extra scope, to make sure "buff01" is destructed before producer.
+            testAdmin.Sync("setup producer");
+
+            uint32_t bufferSize = 8 * 1024;
+            uint32_t result;
+            Core::SharedBuffer buff01(bufferName.c_str());
+
+            testAdmin.Sync("setup consumer");
+
+            result = buff01.RequestConsume(Core::infinite);
+            EXPECT_EQ(result, Core::ERROR_NONE);
+
+            uint8_t * buffer = buff01.Buffer();
+            EXPECT_EQ(buff01.Size(), bufferSize);
+
+            EXPECT_EQ(buffer[0], 42);
+            EXPECT_EQ(buffer[1], 43);
+            EXPECT_EQ(buffer[2], 44);
+
+            buff01.Consumed();
+            EXPECT_EQ(result, Core::ERROR_NONE);
+        }
+
+        testAdmin.Sync("consumer done");
+
+        Core::Singleton::Dispose();
+    }
+} // Tests
+} // WPEFramework
diff --git b/Tests/core/test_singleton.cpp b/Tests/core/test_singleton.cpp
new file mode 100644
index 0000000..d56519b
--- /dev/null
+++ b/Tests/core/test_singleton.cpp
@@ -0,0 +1,71 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+class SingletonTypeOne {
+    public:
+        SingletonTypeOne()
+        {
+        }
+        virtual ~SingletonTypeOne()
+        {
+        }
+};
+
+class SingletonTypeTwo {
+    public:
+        SingletonTypeTwo(string)
+        {
+        }
+        virtual ~SingletonTypeTwo()
+        {
+        }
+};
+class SingletonTypeThree {
+    public:
+        SingletonTypeThree (string, string)
+        {
+        }
+        virtual ~SingletonTypeThree()
+        {
+        }
+};
+
+
+TEST(test_singleton, simple_singleton)
+{
+    static SingletonTypeOne& object1 = SingletonType<SingletonTypeOne>::Instance();
+    static SingletonTypeOne& object_sample = SingletonType<SingletonTypeOne>::Instance();
+    EXPECT_EQ(&object1,&object_sample);
+    static SingletonTypeTwo& object2 = SingletonType<SingletonTypeTwo>::Instance("SingletonTypeTwo");
+    static SingletonTypeThree& object3 = SingletonType<SingletonTypeThree>::Instance("SingletonTypeThree","SingletonTypeThree");
+    SingletonType<SingletonTypeTwo>* x = (SingletonType<SingletonTypeTwo>*)&object2;
+    EXPECT_STREQ(x->ImplementationName().c_str(),"SingletonTypeTwo");
+    SingletonType<SingletonTypeThree>* y = (SingletonType<SingletonTypeThree>*)&object3;
+    EXPECT_STREQ(y->ImplementationName().c_str(),"SingletonTypeThree");
+    Singleton::Dispose();
+}
+
diff --git b/Tests/core/test_socketstreamjson.cpp b/Tests/core/test_socketstreamjson.cpp
new file mode 100644
index 0000000..cbeb8a4
--- /dev/null
+++ b/Tests/core/test_socketstreamjson.cpp
@@ -0,0 +1,271 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+#include <websocket/websocket.h>
+#include <condition_variable>
+#include <mutex>
+
+namespace WPEFramework {
+namespace Tests {
+
+    enum class CommandType {
+        EXECUTESHELL,
+        WIFISETTINGS,
+        FANCONTROL,
+        PLAYERCONTROL
+    };
+
+    class Parameters : public Core::JSON::Container {
+    public:
+        Parameters(const Parameters&) = delete;
+        Parameters& operator=(const Parameters&) = delete;
+
+        Parameters()
+            : Core::JSON::Container()
+            , Speed(0)
+            , Duration(0)
+            , Command()
+            , Settings()
+        {
+            Add(_T("speed"), &Speed);
+            Add(_T("duration"), &Duration);
+            Add(_T("command"), &Command);
+            Add(_T("settings"), &Settings);
+        }
+
+       ~Parameters()
+        {
+        }
+
+    public:
+        Core::JSON::OctSInt16 Speed;
+        Core::JSON::DecUInt16 Duration;
+        Core::JSON::EnumType<CommandType> Command;
+        Core::JSON::ArrayType<Core::JSON::DecUInt16> Settings;
+    };
+
+    class Command : public Core::JSON::Container {
+    public:
+        Command(const Command&) = delete;
+        Command& operator=(const Command&) = delete;
+
+        Command()
+            : Core::JSON::Container()
+            , Identifier(0)
+            , Name()
+            , BaseAddress(0)
+            , TrickFlag(false)
+            , Params()
+        {
+            Add(_T("id"), &Identifier);
+            Add(_T("name"), &Name);
+            Add(_T("baseAddress"), &BaseAddress);
+            Add(_T("trickFlag"), &TrickFlag);
+            Add(_T("parameters"), &Params);
+        }
+
+        ~Command()
+        {
+        }
+
+    public:
+        Core::JSON::DecUInt32 Identifier;
+        Core::JSON::String Name;
+        Core::JSON::HexUInt32 BaseAddress;
+        Core::JSON::Boolean TrickFlag;
+        Parameters Params;
+    };
+
+    class JSONObjectFactory : public Core::ProxyPoolType<Command> {
+    public:
+        JSONObjectFactory() = delete;
+        JSONObjectFactory(const JSONObjectFactory&) = delete;
+        JSONObjectFactory& operator= (const JSONObjectFactory&) = delete;
+
+        JSONObjectFactory(const uint32_t number) : Core::ProxyPoolType<Command>(number)
+        {
+        }
+
+        virtual ~JSONObjectFactory()
+        {
+        }
+
+    public:
+        Core::ProxyType<Core::JSON::IElement> Element(const string&)
+        {
+            return (Core::proxy_cast<Core::JSON::IElement>(Core::ProxyPoolType<Command>::Element()));
+        }
+    };
+
+    template<typename INTERFACE>
+    class JSONConnector : public Core::StreamJSONType<Core::SocketStream, JSONObjectFactory&, INTERFACE> {
+    private:
+        typedef Core::StreamJSONType<Core::SocketStream, JSONObjectFactory&, INTERFACE> BaseClass;
+
+    public:
+        JSONConnector() = delete;
+        JSONConnector(const JSONConnector& copy) = delete;
+        JSONConnector& operator=(const JSONConnector&) = delete;
+
+        JSONConnector(const Core::NodeId& remoteNode)
+            : BaseClass(5, _objectFactory, false, remoteNode.AnyInterface(), remoteNode, 1024, 1024)
+            , _serverSocket(false)
+            , _dataPending(false, false)
+            , _objectFactory(1)
+        {
+        }
+
+        JSONConnector(const SOCKET& connector, const Core::NodeId& remoteId, Core::SocketServerType<JSONConnector<INTERFACE>>*)
+            : BaseClass(5, _objectFactory, false, connector, remoteId, 1024, 1024)
+            , _serverSocket(true)
+            , _dataPending(false, false)
+            , _objectFactory(1)
+        {
+        }
+
+        virtual ~JSONConnector()
+        {
+        }
+
+    public:
+        virtual void Received(Core::ProxyType<Core::JSON::IElement>& newElement)
+        {
+            string textElement;
+            newElement->ToString(textElement);
+
+            if (_serverSocket)
+                this->Submit(newElement);
+            else {
+                _dataReceived = textElement;
+                _dataPending.Unlock();
+            }
+        }
+
+        virtual void Send(Core::ProxyType<Core::JSON::IElement>& newElement)
+        {
+        }
+
+        virtual void StateChange()
+        {
+            if (this->IsOpen()) {
+                if (_serverSocket) {
+                    std::unique_lock<std::mutex> lk(_mutex);
+                    _done = true;
+                    _cv.notify_one();
+                 }
+            }
+        }
+
+        virtual bool IsIdle() const
+        {
+            return (true);
+        }
+
+        int Wait() const
+        {
+            return _dataPending.Lock();
+        }
+
+        void Retrieve(string& text)
+        {
+            text = _dataReceived;
+            _dataReceived.clear();
+        }
+
+        static bool GetState()
+        {
+            return _done;
+        }
+
+    private:
+        bool _serverSocket;
+        string _dataReceived;
+        mutable Core::Event _dataPending;
+        JSONObjectFactory _objectFactory;
+        static bool _done;
+
+    public:
+        static std::mutex _mutex;
+        static std::condition_variable _cv;
+    };
+
+    template<typename INTERFACE>
+    std::mutex JSONConnector<INTERFACE>::_mutex;
+    template<typename INTERFACE>
+    std::condition_variable JSONConnector<INTERFACE>::_cv;
+    template<typename INTERFACE>
+    bool JSONConnector<INTERFACE>::_done = false;
+
+    TEST(Core_Socket, StreamJSON)
+    {
+        std::string connector = "/tmp/wpestreamjson0";
+        auto lambdaFunc = [connector](IPTestAdministrator & testAdmin) {
+            Core::SocketServerType<JSONConnector<Core::JSON::IElement>> jsonSocketServer(Core::NodeId(connector.c_str()));
+            jsonSocketServer.Open(Core::infinite);
+            testAdmin.Sync("setup server");
+            std::unique_lock<std::mutex> lk(JSONConnector<Core::JSON::IElement>::_mutex);
+            while (!JSONConnector<Core::JSON::IElement>::GetState()) {
+                JSONConnector<Core::JSON::IElement>::_cv.wait(lk);
+            }
+
+            testAdmin.Sync("server open");
+            testAdmin.Sync("client done");
+        };
+
+        static std::function<void (IPTestAdministrator&)> lambdaVar = lambdaFunc;
+
+        IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin ) { lambdaVar(testAdmin); };
+
+        IPTestAdministrator testAdmin(otherSide);
+        testAdmin.Sync("setup server");
+        {
+            Core::ProxyType<Command> sendObject = Core::ProxyType<Command>::Create();
+            sendObject->Identifier = 1;
+            sendObject->Name = _T("TestCase");
+            sendObject->Params.Duration = 100;
+            std::string sendString;
+            sendObject->ToString(sendString);
+
+            JSONConnector<Core::JSON::IElement> jsonSocketClient(Core::NodeId(connector.c_str()));
+            jsonSocketClient.Open(Core::infinite);
+            testAdmin.Sync("server open");
+            jsonSocketClient.Submit(Core::proxy_cast<Core::JSON::IElement>(sendObject));
+            jsonSocketClient.Wait();
+            string received;
+            jsonSocketClient.Retrieve(received);
+            EXPECT_STREQ(sendString.c_str(), received.c_str());
+            jsonSocketClient.Close(Core::infinite);
+            testAdmin.Sync("client done");
+       }
+       Core::Singleton::Dispose();
+    }
+} // Tests
+
+ENUM_CONVERSION_BEGIN(Tests::CommandType)
+    { Tests::CommandType::EXECUTESHELL, _TXT("ExecuteShell") },
+    { Tests::CommandType::WIFISETTINGS, _TXT("WiFiSettings") },
+    { Tests::CommandType::FANCONTROL, _TXT("FanControl") },
+    { Tests::CommandType::PLAYERCONTROL, _TXT("PlayerControl") },
+ENUM_CONVERSION_END(Tests::CommandType)
+
+} // WPEFramework
diff --git b/Tests/core/test_socketstreamtext.cpp b/Tests/core/test_socketstreamtext.cpp
new file mode 100644
index 0000000..ce08195
--- /dev/null
+++ b/Tests/core/test_socketstreamtext.cpp
@@ -0,0 +1,153 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+#include <websocket/websocket.h>
+#include <condition_variable>
+#include <mutex>
+
+namespace WPEFramework {
+namespace Tests {
+
+    class TextConnector : public Core::StreamTextType<Core::SocketStream, Core::TerminatorCarriageReturn> {
+    private:
+        typedef Core::StreamTextType<Core::SocketStream, Core::TerminatorCarriageReturn> BaseClass;
+
+    public:
+        TextConnector() = delete;
+        TextConnector(const TextConnector& copy) = delete;
+        TextConnector& operator=(const TextConnector&) = delete;
+
+        TextConnector(const WPEFramework::Core::NodeId& remoteNode)
+            : BaseClass(false, remoteNode.AnyInterface(), remoteNode, 1024, 1024)
+            , _serverSocket(false)
+            , _dataPending(false, false)
+        {
+        }
+
+        TextConnector(const SOCKET& connector, const Core::NodeId& remoteId, Core::SocketServerType<TextConnector>*)
+            : BaseClass(false, connector, remoteId, 1024, 1024)
+            , _serverSocket(true)
+            , _dataPending(false, false)
+        {
+        }
+
+        virtual ~TextConnector()
+        {
+        }
+
+    public:
+        virtual void Received(string& text)
+        {
+            if (_serverSocket)
+                Submit(text);
+            else {
+                _dataReceived = text;
+                _dataPending.Unlock();
+            }
+        }
+
+        int Wait() const
+        {
+            return _dataPending.Lock();
+        }
+
+        void Retrieve(string& text)
+        {
+            text = _dataReceived;
+            _dataReceived.clear();
+        }
+
+        virtual void Send(const string& text)
+        {
+        }
+
+        virtual void StateChange()
+        {
+            if (IsOpen()) {
+                if (_serverSocket) {
+                    std::unique_lock<std::mutex> lk(_mutex);
+                    _done = true;
+                    _cv.notify_one();
+                }
+            }
+        }
+
+        static bool GetState()
+        {
+            return _done;
+        }
+
+    private:
+        bool _serverSocket;
+        string _dataReceived;
+        mutable WPEFramework::Core::Event _dataPending;
+        static bool _done;
+
+    public:
+        static std::mutex _mutex;
+        static std::condition_variable _cv;
+    };
+
+    std::mutex TextConnector::_mutex;
+    std::condition_variable TextConnector::_cv;
+    bool TextConnector::_done = false;
+
+    TEST(Core_Socket, StreamText)
+    {
+        std::string connector {"/tmp/wpestreamtext0"};
+
+        auto lambdaFunc = [connector](IPTestAdministrator & testAdmin) {
+            Core::SocketServerType<TextConnector> textSocketServer(Core::NodeId(connector.c_str()));
+            textSocketServer.Open(Core::infinite);
+            testAdmin.Sync("setup server");
+            std::unique_lock<std::mutex> lk(TextConnector::_mutex);
+            while (!TextConnector::GetState()) {
+                TextConnector::_cv.wait(lk);
+            }
+            testAdmin.Sync("server open");
+            testAdmin.Sync("client done");
+        };
+
+        static std::function<void (IPTestAdministrator&)> lambdaVar = lambdaFunc;
+
+        IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin ) { lambdaVar(testAdmin); };
+
+        IPTestAdministrator testAdmin(otherSide);
+        testAdmin.Sync("setup server");
+        {
+            TextConnector textSocketClient(Core::NodeId(connector.c_str()));
+            textSocketClient.Open(Core::infinite);
+            testAdmin.Sync("server open");
+            string message = "hello";
+            textSocketClient.Submit(message);
+            textSocketClient.Wait();
+            string received;
+            textSocketClient.Retrieve(received);
+            EXPECT_STREQ(message.c_str(), received.c_str());
+            textSocketClient.Close(Core::infinite);
+            testAdmin.Sync("client done");
+        }
+        Core::Singleton::Dispose();
+    }
+} // Tests
+} // WPEFramework
diff --git b/Tests/core/test_statetrigger.cpp b/Tests/core/test_statetrigger.cpp
new file mode 100644
index 0000000..ac0033f
--- /dev/null
+++ b/Tests/core/test_statetrigger.cpp
@@ -0,0 +1,36 @@
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+enum class TestState {
+    TEST_INIT = 0x00,
+    TEST_MESSAGE = 0x01,
+    TEST_READY = 0x02,
+    TEST_ERROR = 0x03
+};
+
+TEST(test_statetrigger, simple_statetrigger)
+{
+    WPEFramework::Core::StateTrigger<TestState> state(TestState::TEST_READY);
+
+    EXPECT_EQ(state.GetState(),TestState::TEST_READY) << "State not equal to TEST_READY.";
+    state.SetState(TestState::TEST_MESSAGE);
+    EXPECT_NE(state.GetState(),TestState::TEST_READY) << "State is TEST_MESSAGE.";
+    EXPECT_TRUE(state.GetState() == TestState::TEST_MESSAGE) << "State is not TEST_MESSAGE";
+    EXPECT_FALSE(state.GetState() != TestState::TEST_MESSAGE) << "State is TEST_MESSAGE";
+    state = TestState::TEST_READY;
+
+    uint64_t timeOut(Core::Time::Now().Add(5).Ticks());
+    uint64_t now(Core::Time::Now().Ticks());
+
+    state.WaitState(static_cast<uint32_t>(TestState::TEST_INIT),static_cast<uint32_t>((timeOut - now) / Core::Time::TicksPerMillisecond));
+
+    timeOut = Core::Time::Now().Add(3).Ticks();
+    now = Core::Time::Now().Ticks();
+
+    state.WaitStateClear(static_cast<uint32_t>(TestState::TEST_READY),static_cast<uint32_t>((timeOut - now) / Core::Time::TicksPerMillisecond));
+}
diff --git b/Tests/core/test_stopwatch.cpp b/Tests/core/test_stopwatch.cpp
new file mode 100644
index 0000000..902f652
--- /dev/null
+++ b/Tests/core/test_stopwatch.cpp
@@ -0,0 +1,38 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+TEST(test_stopWatch, simple_stopWatch)
+{
+     StopWatch stopwatch;
+     uint64_t elapsed = stopwatch.Elapsed();
+     uint64_t elapsed1 = elapsed;
+     EXPECT_EQ(elapsed,elapsed1);
+     
+     uint64_t reset = stopwatch.Reset();
+     uint64_t reset1 = reset;
+     EXPECT_EQ(reset,reset1);
+}
diff --git b/Tests/core/test_synchronize.cpp b/Tests/core/test_synchronize.cpp
new file mode 100644
index 0000000..b3f58bb
--- /dev/null
+++ b/Tests/core/test_synchronize.cpp
@@ -0,0 +1,75 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+class SynchronizeClass {
+public:
+    SynchronizeClass()
+        : _msg("")
+    {
+    }
+
+    ~SynchronizeClass()
+    {
+    }
+
+public:
+    bool Copy(const string message)
+    {
+        bool result = false;
+        _msg = message;
+        if (!_msg.empty())
+            result = true;
+        return result;
+    }
+
+private:
+    string _msg;
+};
+
+TEST(test_synchronize, synchronize_test)
+{
+    string MESSAGE = "SynchronizeType request";
+    SynchronizeClass syncObject1;
+    SynchronizeType<string> syncObject2;
+    SynchronizeType<SynchronizeClass> syncObject3;
+
+    syncObject2.Load();
+    syncObject2.Evaluate();
+
+    syncObject3.Load(syncObject1);
+    EXPECT_EQ(syncObject3.Aquire(unsigned(5)), unsigned(11));
+    syncObject3.Load(syncObject1);
+    EXPECT_TRUE(syncObject3.Evaluate<string>(MESSAGE));
+
+    syncObject2.Lock();
+    syncObject2.Flush();
+    syncObject2.Unlock();
+
+    syncObject3.Lock();
+    syncObject3.Flush();
+    syncObject3.Unlock();
+}
diff --git b/Tests/core/test_synchronous.cpp b/Tests/core/test_synchronous.cpp
new file mode 100644
index 0000000..a4657c0
--- /dev/null
+++ b/Tests/core/test_synchronous.cpp
@@ -0,0 +1,179 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+namespace {
+    const string localhost = "127.0.0.1";
+    const uint16_t portNumber = 9749;
+    const uint16_t bufferSize = 1024;
+}
+
+class Message : public Core::IOutbound {
+protected:
+    Message(uint8_t buffer[])
+    : _buffer(buffer)
+    {
+    }
+
+public:
+    Message() = delete;
+    Message(const Message&) = delete;
+    Message& operator=(const Message&) = delete;
+
+    Message(const uint16_t size, uint8_t buffer[])
+        : _size(size)
+        , _buffer(buffer)
+        , _offset(0)
+    {
+    }
+
+    virtual ~Message()
+    {
+    }
+
+private:
+    virtual void Reload() const override
+    {
+        _offset = 0;
+    }
+
+    virtual uint16_t Serialize(uint8_t stream[], const uint16_t length) const override
+    {
+        uint16_t result = std::min(static_cast<uint16_t>(sizeof(_buffer) - _offset), length);
+        if (result > 0) {
+
+            ::memcpy(stream, &(_buffer[_offset]), result);
+            _offset += result;
+        }
+        return (result);
+    }
+
+private:
+    uint16_t _size;
+    uint8_t* _buffer;
+    mutable uint16_t _offset;
+};
+
+class InMessage : public Core::IInbound {
+protected:
+    InMessage(uint8_t buffer[])
+       : _buffer(buffer)
+    {
+    }
+
+public:
+    InMessage(const InMessage&) = delete;
+    InMessage& operator=(const InMessage&) = delete;
+
+    InMessage()
+        : _buffer()
+        , _error(~0)
+        , _offset(0)
+    {
+    }
+
+    virtual ~InMessage()
+    {
+    }
+
+private:
+    virtual uint16_t Deserialize(const uint8_t stream[], const uint16_t length) override
+    {
+        uint16_t result = 0;
+        uint16_t toCopy = std::min(static_cast<uint16_t>(sizeof(_buffer)-_offset), length);
+        ::memcpy(reinterpret_cast<uint8_t*>(&stream), &(_buffer[_offset]), toCopy);
+
+        _error = Core::ERROR_NONE;
+        result = length;
+        return (result);
+    }
+
+    virtual state IsCompleted() const override 
+    {
+        return (_error != static_cast<uint16_t>(~0) ? state::COMPLETED : state::INPROGRESS);
+    }
+
+private:
+    uint8_t* _buffer;
+    mutable uint16_t _error;
+    mutable uint16_t _offset;
+};
+
+class SynchronousSocket : public Core::SynchronousChannelType<Core::SocketPort> {
+public:
+    SynchronousSocket(const SynchronousSocket&) = delete;
+    SynchronousSocket& operator=(const SynchronousSocket&) = delete;
+    SynchronousSocket() = delete;
+
+    SynchronousSocket(bool listening)
+        :SynchronousChannelType<SocketPort>((listening ? SocketPort::LISTEN : SocketPort::STREAM),listening ?Core::NodeId(_T(localhost.c_str()),(portNumber),Core::NodeId::TYPE_IPV4):Core::NodeId(_T(localhost.c_str()),(portNumber),Core::NodeId::TYPE_DOMAIN),listening ?Core::NodeId(_T(localhost.c_str()),(portNumber),Core::NodeId::TYPE_DOMAIN):Core::NodeId(_T(localhost.c_str()),(portNumber),Core::NodeId::TYPE_IPV4), bufferSize, bufferSize)
+    {
+        EXPECT_FALSE(Core::SynchronousChannelType<Core::SocketPort>::Open(Core::infinite) != Core::ERROR_NONE);
+    }
+
+    virtual ~SynchronousSocket()
+    {
+        Core::SynchronousChannelType<Core::SocketPort>::Close(Core::infinite);
+    }
+
+    virtual uint16_t Deserialize(const uint8_t* dataFrame, const uint16_t availableData)
+    {
+        return 1;
+    }
+};
+
+TEST(test_synchronous, simple_synchronous)
+{
+    IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin) {
+        SynchronousSocket synchronousServerSocket(true);
+        testAdmin.Sync("setup server");
+
+        testAdmin.Sync("connect client");
+        testAdmin.Sync("client msg");
+        testAdmin.Sync("client newmsg");
+        testAdmin.Sync("client revokemsg");
+    };
+
+    IPTestAdministrator testAdmin(otherSide);
+    {
+        testAdmin.Sync("setup server");
+        SynchronousSocket synchronousClientSocket(false);
+
+        testAdmin.Sync("connect client");
+        uint8_t buffer[] = "Hello";
+        Message message(5,buffer);
+        EXPECT_EQ(synchronousClientSocket.Exchange(500, message),0u);
+        testAdmin.Sync("client msg");
+       
+        InMessage response; 
+        Message newmessage(5,buffer);
+        synchronousClientSocket.Exchange(500, newmessage, response);//TODO Output verification is pending.
+        testAdmin.Sync("client newmsg");
+        synchronousClientSocket.Revoke(message);
+        testAdmin.Sync("client revokemsg");
+    }
+    Core::Singleton::Dispose();
+}
diff --git b/Tests/core/test_systeminfo.cpp b/Tests/core/test_systeminfo.cpp
new file mode 100644
index 0000000..b23fbcc
--- /dev/null
+++ b/Tests/core/test_systeminfo.cpp
@@ -0,0 +1,75 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+TEST(Core_SystemInfo, systemInfo)
+{
+    const uint8_t* rawDeviceId (WPEFramework::Core::SystemInfo::Instance().RawDeviceId());
+
+    string id (WPEFramework::Core::SystemInfo::Instance().Id(rawDeviceId, 0xFF));
+    string id_new (WPEFramework::Core::SystemInfo::Instance().Id(rawDeviceId, 0x11));
+
+    std::cout << "SystemInfo Test:" << std::endl;
+
+    std::cout << "Test GetId: " << id << std::endl;
+
+    // std::cout << "Test GetPrefix: " << WPEFramework::Core::SystemInfo::Instance().GetPrefix() << std::endl;
+
+    std::cout << "Test GetHostname: " << WPEFramework::Core::SystemInfo::Instance().GetHostName() << std::endl;
+
+    std::cout << "Test GetUpTime: " << WPEFramework::Core::SystemInfo::Instance().GetUpTime() << " s" << std::endl;
+
+    std::cout << "Test GetTotalRam: " << WPEFramework::Core::SystemInfo::Instance().GetTotalRam() << " bytes" << std::endl;
+
+    std::cout << "Test GetFreeRam: " << WPEFramework::Core::SystemInfo::Instance().GetFreeRam() << " bytes" << std::endl;
+
+    //std::cout << "Test GetTotalGpuRam: " << WPEFramework::Core::SystemInfo::Instance().GetTotalGpuRam() << " bytes" << std::endl;
+
+    //std::cout << "Test GetFreeGpuRam: " << WPEFramework::Core::SystemInfo::Instance().GetFreeGpuRam() << " bytes" << std::endl;
+
+    std::cout << "Test Ticks(Time stamp counter): " << WPEFramework::Core::SystemInfo::Instance().Ticks() << std::endl;
+
+    for (int a = 0; a < 3; a++) {
+        std::cout << a << ". Test GetCpuLoad: " << WPEFramework::Core::SystemInfo::Instance().GetCpuLoad() << " %" << std::endl;
+    }
+    std::string variable = "TEST_VARIABLE";
+    std::string variable_value = "test value";
+    bool forced = true;
+    std::cout << "Test SetEnvironment: " << std::endl;
+    WPEFramework::Core::SystemInfo::Instance().SetEnvironment(variable, variable_value, forced);
+    variable_value.clear();
+    std::cout << "\t" << variable << " : " << (WPEFramework::Core::SystemInfo::Instance().GetEnvironment(variable, variable_value) ? variable_value : "--")  << std::endl;
+}
+
+TEST(Core_SystemInfo, memorySnapShot)
+{
+    WPEFramework::Core::SystemInfo::MemorySnapshot snapshot = WPEFramework::Core::SystemInfo::Instance().TakeMemorySnapshot();
+    std::cout<<"JSON : "<<snapshot.AsJSON()<<std::endl;
+    std::cout<<"Total : "<<snapshot.Total()<<std::endl;
+    std::cout<<"Free : "<<snapshot.Free()<<std::endl;
+    std::cout<<"Available : "<<snapshot.Available()<<std::endl;
+    std::cout<<"Cached : "<<snapshot.Cached()<<std::endl;
+    std::cout<<"SwapTotal : "<<snapshot.SwapTotal()<<std::endl;
+    std::cout<<"SwapFree : "<<snapshot.SwapFree()<<std::endl;
+    std::cout<<"SwapCached: "<<snapshot.SwapCached()<<std::endl;
+}
diff --git b/Tests/core/test_textfragment.cpp b/Tests/core/test_textfragment.cpp
new file mode 100644
index 0000000..69e6470
--- /dev/null
+++ b/Tests/core/test_textfragment.cpp
@@ -0,0 +1,77 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+TEST(test_textfragment, simple_textfragement)
+{
+    string buffer = "/Service/testing/test";
+    TextFragment result;
+    result = TextFragment(string(buffer));
+    TextFragment(string(buffer));
+    TextSegmentIterator index(TextFragment(string(buffer), 16, 5), false,'/');
+    index.Next();
+    index.Next();
+
+    EXPECT_STREQ(index.Remainder().Text().c_str(), _T("test")) << "The remainder string is not test";
+    EXPECT_STREQ(index.Remainder().Data(), _T("test")) << "The remainder string is not test";
+    EXPECT_STREQ(index.Current().Text().c_str(), _T("test")) << "The current string is not test";
+    EXPECT_EQ(index.Remainder().Length(), 4u) << "The length of the string is not 4.";
+    EXPECT_FALSE(index.Remainder().IsEmpty());
+    
+    TextFragment textFragment();
+    const TCHAR buffer_new[] = "/Service/testing/test";
+    TextFragment textFragment1(buffer_new);
+    TextFragment textFragment2(buffer_new,21);
+    TextFragment textFragment3(buffer_new,16,5);
+
+    char delimiter[] = {'/'};
+    EXPECT_EQ(textFragment1.ForwardFind(delimiter),0u);
+    textFragment1.Clear();
+    EXPECT_EQ(textFragment2[1],'S');
+
+    EXPECT_FALSE(textFragment1 == buffer_new);
+    EXPECT_FALSE(textFragment1 == buffer);
+    EXPECT_TRUE(textFragment1 != buffer_new);
+    EXPECT_TRUE(textFragment1 != buffer);
+
+    EXPECT_TRUE(textFragment2.OnMarker(buffer_new));
+    EXPECT_TRUE(textFragment2.EqualText(buffer_new));
+
+    const TCHAR begin[] = "Service";
+    const TCHAR end[] = "test";
+    const TCHAR middle[] = "testing";
+    textFragment2.TrimBegin(begin);
+    textFragment2.TrimEnd(end);
+    EXPECT_EQ(textFragment2.ReverseFind(middle),15u);
+    EXPECT_EQ(textFragment2.ReverseSkip(middle),16u);
+
+    const TCHAR splitters[] ={'/',','};
+    TextSegmentIterator iterator1(TextFragment(string(buffer), 16, 5), false,splitters);
+    TextSegmentIterator iterator2(iterator1);
+    index = iterator2;
+    iterator2.Reset();
+    TextSegmentIterator iterator3();
+}
diff --git b/Tests/core/test_textreader.cpp b/Tests/core/test_textreader.cpp
new file mode 100644
index 0000000..9454975
--- /dev/null
+++ b/Tests/core/test_textreader.cpp
@@ -0,0 +1,42 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+TEST(test_TextReader, simple_TextReader)
+{
+    TextReader();
+
+    uint8_t* val = (uint8_t*) "Checking the fragment";
+    DataElement element(21,val);
+
+    TextReader Reader(element);
+    TextReader Reader1(Reader);
+
+    Reader.Reset();
+    EXPECT_FALSE(Reader.EndOfText());
+    TextFragment fragment = Reader.ReadLine();
+    EXPECT_STREQ(fragment.Data(),"Checking the fragment");
+}
diff --git b/Tests/core/test_thread.cpp b/Tests/core/test_thread.cpp
new file mode 100644
index 0000000..af1a237
--- /dev/null
+++ b/Tests/core/test_thread.cpp
@@ -0,0 +1,140 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+#include <condition_variable>
+#include <mutex>
+
+namespace WPEFramework {
+namespace Tests {
+
+    class ThreadClass : public Core::Thread {
+    public:
+        ThreadClass() = delete;
+        ThreadClass(const ThreadClass&) = delete;
+        ThreadClass& operator=(const ThreadClass&) = delete;
+
+        ThreadClass(volatile bool& threadDone, std::mutex& mutex, std::condition_variable& cv, ::ThreadId parentTid)
+            : Core::Thread(Core::Thread::DefaultStackSize(), _T("Test"))
+            , _done(threadDone)
+            , _threadMutex(mutex)
+            , _threadCV(cv)
+            , _parentTid(parentTid)
+        {
+        }
+
+        virtual ~ThreadClass()
+        {
+        }
+
+        virtual uint32_t Worker() override
+        {
+            while (IsRunning() && (!_done)) {
+                EXPECT_NE(_parentTid, Core::Thread::ThreadId());
+                std::unique_lock<std::mutex> lk(_threadMutex);
+                _done = true;
+                _threadCV.notify_one();
+            }
+            return (Core::infinite);
+        }
+
+    private :
+        volatile bool& _done;
+        std::mutex& _threadMutex;
+        std::condition_variable& _threadCV;
+        ::ThreadId _parentTid;
+    };
+
+    class Job : public Core::IDispatch {
+    public:
+        Job(const Job&) = delete;
+        Job& operator=(const Job&) = delete;
+
+        Job()
+        {
+        }
+
+        ~Job()
+        {
+        }
+
+        virtual void Dispatch() override
+        {
+            EXPECT_NE(_parentTPid, Core::Thread::ThreadId());
+            std::unique_lock<std::mutex> lk(_mutex);
+            _threadDone = true;
+            _cv.notify_one();
+        }
+
+        static bool GetState()
+        {
+            return _threadDone;
+        }
+
+    private:
+        static bool _threadDone;
+        static ::ThreadId _parentTPid;
+
+    public:
+        static std::mutex _mutex;
+        static std::condition_variable _cv;
+    };
+
+    bool Job::_threadDone = false;
+    std::mutex Job::_mutex;
+    std::condition_variable Job::_cv;
+    ::ThreadId Job::_parentTPid = Core::Thread::ThreadId();
+
+    TEST(Core_Thread, SimpleThread)
+    {
+        ::ThreadId parentTid = Core::Thread::ThreadId();
+        volatile bool threadDone = false;
+        std::mutex mutex;
+        std::condition_variable cv;
+
+        ThreadClass object(threadDone, mutex, cv, parentTid);
+        object.Run();
+        EXPECT_EQ(object.State(), Core::Thread::RUNNING);
+        std::unique_lock<std::mutex> lk(mutex);
+        while (!threadDone) {
+            cv.wait(lk);
+        }
+        object.Stop();
+        EXPECT_EQ(object.State(), Core::Thread::STOPPING);
+        object.Wait(Core::Thread::BLOCKED | Core::Thread::STOPPED | Core::Thread::STOPPING, Core::infinite);
+    }
+#if 0 //TODO
+    TEST(Core_Thread, ThreadPool)
+    {
+        Core::ProxyType<Core::IDispatch> job(Core::ProxyType<Job>::Create());
+        Core::ThreadPoolType<Core::Job, 1> executor(0, _T("TestPool"));
+        executor.Submit(Core::Job(job), Core::infinite);
+
+        std::unique_lock<std::mutex> lk(Job::_mutex);
+        while (!Job::GetState()) {
+            Job::_cv.wait(lk);
+        }
+        Core::Singleton::Dispose();
+    }
+#endif
+} // Tests
+} // WPEFramework
diff --git b/Tests/core/test_time.cpp b/Tests/core/test_time.cpp
new file mode 100644
index 0000000..98e533f
--- /dev/null
+++ b/Tests/core/test_time.cpp
@@ -0,0 +1,198 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/Time.h>
+#include <core/SystemInfo.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+TEST(Core_Time, timedetails)
+{
+    Time time (Time::Now());
+    std::string timeString;
+    time.ToString(timeString);
+    time.ToRFC1123();
+    time.Format("%d-%m-%Y");
+    time.MilliSeconds();
+    time.Seconds();
+    time.Minutes();
+    time.Hours();
+    time.Day();
+    time.Month();
+    time.Year();
+    time.MonthName();
+    time.WeekDayName();
+    time.DayOfWeek();
+    time.DayOfYear();
+    time.Ticks();
+    time.NTPTime();
+    time.DifferenceFromGMTSeconds();
+    time.FromRFC1123(timeString); 
+    
+    Time::Now().ToRFC1123();
+    time.Add (2000);
+    SystemInfo::Instance().SetTime(time);
+    Time::Now().ToRFC1123();
+
+    time.Sub (2000);
+    SystemInfo::Instance().SetTime(time);
+    Time::Now().ToRFC1123();
+
+    Time t1 =  Time(2018,7,23,11,30,23,21,true);
+    Time t2 =  Time(2018,7,23,11,30,23,21,false);
+    struct tm setTime;
+    ::memcpy(&setTime, &(time.Handle()), sizeof (setTime));
+}
+
+TEST(Core_Time, from_standards)
+{
+    Time time (Time::Now());
+    std::string timeString;
+    time.ToString(timeString);
+
+    time.FromString(timeString,true);
+    time.FromString(timeString,false);
+
+    time.FromANSI(timeString,true);    
+    time.FromANSI(timeString,false);    
+
+    time.FromRFC1036(timeString);
+    time.FromRFC1036("19941105T08:49:37.123+06:45"); 
+    time.FromRFC1036("1994-11-06T08:49:37.123+06:45"); 
+    time.FromRFC1036("1994-11-Jan-T08:12:49:37.123+06:45"); 
+    time.FromRFC1036("1994-11-Jan-T08:12:49:37 123+06:45"); 
+    time.FromRFC1036("1994-11-Jan-08:49:07+06:45");
+    time.FromRFC1036("1994Jan07T08:49:37.123+06:45"); 
+    time.FromRFC1036("1994-Jan-09T08:49:37.123+06:45");
+ 
+    time.FromISO8601(timeString);
+    time.FromISO8601("1994-11-06T08:49:37.123+06:45"); 
+    time.FromISO8601("1994-12-06T08:49:37.123+06:45"); 
+    time.FromISO8601("1994-13-06T08:49:37.123+06:45"); 
+    time.FromISO8601("1994-11-06T08:49:37");
+    time.FromISO8601("1994-12-06T08:49:37.123 06:45");
+    time.FromISO8601("1994-11-06T08:49:37.123-06:45"); 
+    time.FromISO8601("1994-11-06T08:49:37."); 
+    time.FromISO8601("1994-11-06T08:49:37.123+06 45"); 
+    time.FromISO8601("1994-11-06T08:49:37.123+24:45"); 
+    time.FromISO8601("1994-11-06T08:49:37.123+24:4"); 
+    time.FromISO8601("1994-11-06T08:49:37.123+06:45:"); 
+    time.FromISO8601("1994-11-06T08:49:37.123+"); 
+    time.FromISO8601("1994-11-06T08:49:37.123a"); 
+
+    time.FromANSI("1994Jan06T08:49:37.123+06:45",true); 
+    time.FromANSI("1994Jan06T08:49:37.803+06:45",true); 
+    time.FromANSI("1994Jan06T0a:49:37.123+06:45",true); 
+    time.FromANSI("1994Feb06T08:4a:37.123+06:45",true); 
+    time.FromANSI("1994Mar06T08:49:5a.123+06:45",true); 
+    time.FromANSI("1994Mara6T08:49:5a.123+06:45",true); 
+    time.FromANSI("1994Mar0aT08:49:5a.123+06:45",true); 
+}
+
+TEST(Core_Time, to_standards)
+{
+    Time time (Time::Now());
+    time.ToRFC1123(true);
+    time.ToRFC1123(false);
+    Time().ToRFC1123(true);
+
+    time.ToISO8601();
+    time.ToISO8601(true);
+    time.ToISO8601(false);
+    Time().ToISO8601(true);
+}
+
+TEST(Core_Time, FromRFC1123)
+{
+    Time t1 =  Time(2018,1,23,11,30,23,21,false);
+    std::string timeString;
+    t1.ToString(timeString,false);
+    t1.FromRFC1123(timeString);
+    EXPECT_STREQ(timeString.c_str() ,_T("Tue, 23 Jan 2018 11:30:23 GMT"));
+ 
+    t1 =  Time(2018,2,23,11,30,23,21,false);
+    t1.ToString(timeString,false);
+    t1.FromRFC1123(timeString); 
+    EXPECT_STREQ(timeString.c_str() ,_T("Fri, 23 Feb 2018 11:30:23 GMT"));
+
+    t1 =  Time(2018,3,23,11,30,23,21,false);
+    t1.ToString(timeString,false);
+    t1.FromRFC1123(timeString);
+    EXPECT_STREQ(timeString.c_str() ,_T("Fri, 23 Mar 2018 11:30:23 GMT"));
+
+    t1 =  Time(2018,4,23,11,30,23,21,false);
+    t1.ToString(timeString,false);
+    t1.FromRFC1123(timeString);
+    EXPECT_STREQ(timeString.c_str() ,_T("Mon, 23 Apr 2018 11:30:23 GMT"));
+
+    t1 =  Time(2018,5,23,11,30,23,21,false);
+    t1.ToString(timeString,false);
+    t1.FromRFC1123(timeString);
+    EXPECT_STREQ(timeString.c_str() ,_T("Wed, 23 May 2018 11:30:23 GMT"));
+     
+    t1 =  Time(2018,6,23,11,30,23,21,false);
+    t1.ToString(timeString,false);
+    t1.FromRFC1123(timeString); 
+    EXPECT_STREQ(timeString.c_str() ,_T("Sat, 23 Jun 2018 11:30:23 GMT"));
+
+    t1 =  Time(2018,7,23,11,30,23,21,false);
+    t1.ToString(timeString,false);
+    t1.FromRFC1123(timeString);
+    EXPECT_STREQ(timeString.c_str() ,_T("Mon, 23 Jul 2018 11:30:23 GMT"));
+
+    t1 =  Time(2018,8,23,11,30,23,21,false);
+    t1.ToString(timeString,false);
+    t1.FromRFC1123(timeString); 
+    EXPECT_STREQ(timeString.c_str() ,_T("Thu, 23 Aug 2018 11:30:23 GMT"));
+
+    t1 =  Time(2018,9,23,11,30,23,21,false);
+    t1.ToString(timeString,false);
+    t1.FromRFC1123(timeString); 
+    EXPECT_STREQ(timeString.c_str() ,_T("Sun, 23 Sep 2018 11:30:23 GMT"));
+    
+    t1 =  Time(2018,10,23,11,30,23,21,false);
+    t1.ToString(timeString,false);
+    t1.FromRFC1123(timeString); 
+    EXPECT_STREQ(timeString.c_str() ,_T("Tue, 23 Oct 2018 11:30:23 GMT"));
+    
+    t1 =  Time(2018,11,23,11,30,23,21,false);
+    t1.ToString(timeString,false);
+    t1.FromRFC1123(timeString); 
+    EXPECT_STREQ(timeString.c_str() ,_T("Fri, 23 Nov 2018 11:30:23 GMT"));
+
+    t1 =  Time(2018,12,23,11,30,23,21,false);
+    t1.ToString(timeString,false);
+    t1.FromRFC1123(timeString); 
+    EXPECT_STREQ(timeString.c_str() ,_T("Sun, 23 Dec 2018 11:30:23 GMT"));
+
+    t1 =  Time(70,12,23,11,30,23,21,false);
+    t1.ToString(timeString,false);
+    t1.FromRFC1123(timeString);
+
+    t1 =  Time(80,12,23,11,30,23,21,false);
+    t1.ToString(timeString,false);
+    t1.FromRFC1123(timeString);
+
+    t1.FromRFC1123("1994Jan06T08:49:37.123+06:45");
+    t1.FromRFC1123("1994Jan0aT08:49:37.123+06:45");
+}
diff --git b/Tests/core/test_timer.cpp b/Tests/core/test_timer.cpp
new file mode 100644
index 0000000..5d9fbe3
--- /dev/null
+++ b/Tests/core/test_timer.cpp
@@ -0,0 +1,167 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+#include <condition_variable>
+#include <mutex>
+
+namespace WPEFramework {
+namespace Tests {
+
+    class TimeHandler {
+    public:
+        TimeHandler()
+        {
+        }
+
+        ~TimeHandler()
+        {
+        }
+
+    public:
+        uint64_t Timed(const uint64_t scheduledTime)
+        {
+            if (!_timerDone) {
+                Core::Time nextTick = Core::Time::Now();
+                uint32_t time = 100; // 0.1 second
+                nextTick.Add(time);
+                std::unique_lock<std::mutex> lk(_mutex);
+                _timerDone++;
+                _cv.notify_one();
+                return nextTick.Ticks();
+            }
+            std::unique_lock<std::mutex> lk(_mutex);
+            _timerDone++;
+            _cv.notify_one();
+            return 0;
+        }
+
+        static int GetCount()
+        {
+            return _timerDone;
+        }
+
+    private:
+        static int _timerDone;
+
+    public:
+        static std::mutex _mutex;
+        static std::condition_variable _cv;
+    };
+
+    int TimeHandler::_timerDone = 0;
+    std::mutex TimeHandler::_mutex;
+    std::condition_variable TimeHandler::_cv;
+
+    class WatchDogHandler : Core::WatchDogType<WatchDogHandler&> {
+    private:
+        typedef Core::WatchDogType<WatchDogHandler&> BaseClass;
+
+    public:
+        WatchDogHandler& operator=(const WatchDogHandler&) = delete;
+        WatchDogHandler()
+            : BaseClass(Core::Thread::DefaultStackSize(), _T("WatchDogTimer"), *this)
+            , _event(false, false)
+        {
+        }
+        ~WatchDogHandler()
+        {
+        }
+
+        void Start(uint32_t delay)
+        {
+            BaseClass::Arm(delay);
+        }
+
+        uint32_t Expired()
+        {
+            _event.SetEvent();
+            return Core::infinite;
+        }
+
+        int Wait(unsigned int milliseconds) const
+        {
+            return _event.Lock(milliseconds);
+        }
+
+    private:
+        uint32_t _delay;
+        mutable Core::Event _event;
+    };
+
+    TEST(Core_Timer, LoopedTimer)
+    {
+        Core::TimerType<TimeHandler> timer(Core::Thread::DefaultStackSize(), _T("LoopedTimer"));
+        uint32_t time = 100;
+
+        Core::Time nextTick = Core::Time::Now();
+        nextTick.Add(time);
+        timer.Schedule(nextTick.Ticks(), TimeHandler());
+        std::unique_lock<std::mutex> lk(TimeHandler::_mutex);
+        while (!(TimeHandler::GetCount() == 2)) {
+            TimeHandler::_cv.wait(lk);
+        }
+    }
+
+    TEST(Core_Timer, QueuedTimer)
+    {
+        Core::TimerType<TimeHandler> timer(Core::Thread::DefaultStackSize(), _T("QueuedTimer"));
+        uint32_t time = 100;
+
+        Core::Time nextTick = Core::Time::Now();
+        nextTick.Add(time);
+        timer.Schedule(nextTick.Ticks(), TimeHandler());
+
+        nextTick.Add(2 * time);
+        timer.Schedule(nextTick.Ticks(), TimeHandler());
+
+        nextTick.Add(3 * time);
+        timer.Schedule(nextTick.Ticks(), TimeHandler());
+        std::unique_lock<std::mutex> lk(TimeHandler::_mutex);
+        while (!(TimeHandler::GetCount() == 5)) {
+            TimeHandler::_cv.wait(lk);
+        }
+    }
+
+    TEST(Core_Timer, PastTime)
+    {
+        Core::TimerType<TimeHandler> timer(Core::Thread::DefaultStackSize(), _T("PastTime"));
+        uint32_t time = 100; // 0.1 second
+
+        Core::Time pastTime = Core::Time::Now();
+        pastTime.Sub(time);
+        timer.Schedule(pastTime.Ticks(), TimeHandler());
+        std::unique_lock<std::mutex> lk(TimeHandler::_mutex);
+        while (!(TimeHandler::GetCount() == 6)) {
+            TimeHandler::_cv.wait(lk);
+        }
+    }
+
+    TEST(Core_Timer, WatchDogType)
+    {
+        WatchDogHandler timer;
+        timer.Start(100); // 100 milliseconds delay
+        int ret = timer.Wait(200); // Wait for 200 milliseconds
+        EXPECT_EQ(ret, Core::ERROR_NONE);
+    }
+} // Tests
+} // WPEFramework
diff --git b/Tests/core/test_tracing.cpp b/Tests/core/test_tracing.cpp
new file mode 100644
index 0000000..9a3f66b
--- /dev/null
+++ b/Tests/core/test_tracing.cpp
@@ -0,0 +1,264 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <tracing/tracing.h>
+#include <tracing/TraceUnit.h>
+#include <core/Time.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+#pragma pack(push)
+#pragma pack(1)
+struct TraceHeader
+{
+    uint16_t _Length;
+    uint64_t _ClockTicks;
+    uint32_t _LineNumber;
+};
+#pragma pack(pop)
+
+struct TraceData
+{
+    TraceHeader _Header;
+    string _File;
+    string _Module;
+    string _Category;
+    string _Class;
+    string _Text;
+
+    string ToString()
+    {
+        std::stringstream output;
+        output << _File << "(" << _Header._LineNumber << "): " << _Text;
+        return output.str();
+    }
+};
+
+class ServerCyclicBuffer01 : public Core::CyclicBuffer
+{
+public:
+    ServerCyclicBuffer01(const string& fileName)
+        : CyclicBuffer(fileName, 0, true)
+    {
+    }
+
+    virtual uint32_t GetReadSize(Cursor& cursor) override
+    {
+        uint16_t entrySize = 0;
+        cursor.Peek(entrySize);
+        return entrySize;
+    }
+};
+
+bool ReadTraceString(const uint8_t buffer[], uint32_t length, uint32_t& offset, string& output)
+{
+    output = "";
+
+    const char * charBuffer = reinterpret_cast<const char *>(buffer);
+
+    while (true) {
+        char c = charBuffer[offset];
+
+        if (c == '\0') {
+            // Found the end
+            offset++;
+            return true;
+        }
+
+        output += string(1, c);
+        offset++;
+
+        if (offset >= length) {
+            // Buffer overrun
+            return false;
+        }
+    }
+
+    return true;
+}
+
+bool ParseTraceData(const uint8_t buffer[], uint32_t length, uint32_t& offset, TraceData& traceData, uint32_t bufferSize)
+{
+    uint32_t startOffset = offset;
+
+    const TraceHeader * header = reinterpret_cast<const TraceHeader *>(buffer + offset);
+    offset += sizeof(TraceHeader);
+
+    if (offset > length) {
+        std::cerr << "Offset " << offset << " is larger than length " << length << std::endl;
+        return false;
+    }
+
+    traceData._Header = *header;
+    uint16_t entrySize = traceData._Header._Length;
+    EXPECT_TRUE(entrySize <= bufferSize);
+
+    if (!ReadTraceString(buffer, length, offset, traceData._File)) {
+        std::cerr << "Failed to read file name" << std::endl;
+        return false;
+    }
+
+    if (!ReadTraceString(buffer, length, offset, traceData._Module)) {
+        std::cerr << "Failed to read module name" << std::endl;
+        return false;
+    }
+
+    if (!ReadTraceString(buffer, length, offset, traceData._Category)) {
+        std::cerr << "Failed to read category" << std::endl;
+        return false;
+    }
+    if (!ReadTraceString(buffer, length, offset, traceData._Class)) {
+        std::cerr << "Failed to read class name" << std::endl;
+        return false;
+    }
+
+    uint16_t totalHeaderLength = offset - startOffset;
+    uint16_t textLength = entrySize - totalHeaderLength;
+    uint16_t textBufferLength = textLength + 1;
+    char textBuffer[textBufferLength];
+
+    memcpy(textBuffer, buffer + offset, textLength);
+    textBuffer[textLength] = '\0';
+    traceData._Text = string(textBuffer);
+
+    offset += textLength;
+
+    EXPECT_TRUE(offset == (startOffset + entrySize));
+
+    return true;
+}
+
+void DebugCheckIfConsistent(const uint8_t * buffer, int length, Core::CyclicBuffer& cycBuffer, uint32_t bufferSize)
+{
+    uint entryCount = 0;
+
+    int index = 0;
+    while (index < length) {
+        uint16_t entrySize = 0;
+        entrySize += static_cast<uint16_t>(buffer[index]);
+        index++;
+        entrySize += static_cast<uint16_t>(buffer[index]) << 8;
+
+        EXPECT_TRUE(entrySize < bufferSize);
+        index += entrySize - 1;
+
+        entryCount++;
+    }
+
+    EXPECT_TRUE(index == length);
+}
+
+void CreateTraceBuffer(string tracePath)
+{
+    char systemCmd[1024];
+    string command = "mkdir -p ";
+    snprintf(systemCmd, command.size()+tracePath.size()+1, "%s%s", command.c_str(),tracePath.c_str());
+    system(systemCmd);
+}
+
+TEST(Core_tracing, simpleTracing)
+{
+    std::string tracePath = "/tmp/tracebuffer01";
+    auto lambdaFunc = [tracePath](IPTestAdministrator & testAdmin) {
+        std::string db = (tracePath + "/tracebuffer.doorbell");
+        string cycBufferName = (tracePath + "/tracebuffer");
+
+        testAdmin.Sync("client start");
+        Core::DoorBell doorBell(db.c_str());
+        ServerCyclicBuffer01 cycBuffer(cycBufferName);
+
+        // TODO: maximum running time?
+        if (doorBell.Wait(Core::infinite) == Core::ERROR_NONE) {
+            doorBell.Acknowledge();
+            constexpr uint32_t bufferSize = ((8 * 1024) - (sizeof(struct Core::CyclicBuffer::control))); /* 8Kb */
+            uint32_t bufferLength = bufferSize;
+            uint8_t buffer[bufferLength];
+            uint32_t actuallyRead = cycBuffer.Read(buffer, sizeof(buffer));
+            testAdmin.Sync("server done");
+
+            EXPECT_TRUE(actuallyRead < cycBuffer.Size());
+
+            DebugCheckIfConsistent(buffer, actuallyRead, cycBuffer, bufferSize);
+
+            uint32_t offset = 0;
+            int traceCount = 0;
+            while (offset < actuallyRead) {
+                TraceData traceData;
+                EXPECT_TRUE(ParseTraceData(buffer, actuallyRead, offset, traceData, bufferSize));
+                string time(Core::Time::Now().ToRFC1123(true));
+
+                EXPECT_STREQ(traceData._File.c_str(), "test_tracing.cpp");
+                EXPECT_STREQ(traceData._Class.c_str(), "TestBody");
+                EXPECT_STREQ(traceData._Category.c_str(), "Information");
+                EXPECT_STREQ(traceData._Text.c_str(), "Trace Log");
+
+                traceCount++;
+            }
+        }
+        doorBell.Relinquish();
+    };
+
+    static std::function<void (IPTestAdministrator&)> lambdaVar = lambdaFunc;
+
+    IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin ) { lambdaVar(testAdmin); };
+
+    // This side (tested) acts as client.
+    IPTestAdministrator testAdmin(otherSide);
+    {
+        CreateTraceBuffer(tracePath);
+        Trace::TraceUnit::Instance().Open(tracePath);
+        testAdmin.Sync("client start");
+        sleep(2);
+        Trace::TraceType<Trace::Information, &Core::System::MODULE_NAME>::Enable(true);
+
+        TRACE_GLOBAL(Trace::Information, (_T("Trace Log")));
+        testAdmin.Sync("server done");
+
+        Trace::TraceUnit::Instance().SetCategories(true,"Tracing", reinterpret_cast<const char*>("Information"));
+        Trace::TraceUnit::Iterator index = Trace::TraceUnit::Instance().GetCategories();
+
+        while (index.Next() == true)
+            if ((*index)->Enabled() == true) {
+                EXPECT_STREQ((*index)->Module(), "Tracing");
+                EXPECT_STREQ((*index)->Category(), "Information");
+            }
+
+        bool enabled = false;
+        Trace::TraceUnit::Instance().IsDefaultCategory("Tracing", reinterpret_cast<const char*>("Information"), enabled);
+
+#if 0
+        string jsonDefaultCategories("Information");
+        if (jsonDefaultCategories.empty() == false) {
+            Trace::TraceUnit::Instance().SetDefaultCategoriesJson(jsonDefaultCategories);
+        }
+        Trace::TraceUnit::Instance().GetDefaultCategoriesJson(jsonDefaultCategories);
+#endif
+
+        TRACE(Trace::Information,(Trace::Format(_T("Checking the Format() with 1 parameter"))));
+        std::string text = "Hello";
+        TRACE(Trace::Information,(Trace::Format(text.c_str(), _T("Checking the Format() with 2 parameter"))));
+        Trace::TraceUnit::Instance().Close();
+        Trace::TraceUnit::Instance().Open(1);
+   }
+   Core::Singleton::Dispose();
+}
diff --git b/Tests/core/test_tristate.cpp b/Tests/core/test_tristate.cpp
new file mode 100644
index 0000000..f1e6200
--- /dev/null
+++ b/Tests/core/test_tristate.cpp
@@ -0,0 +1,45 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+TEST(test_TriState, simple_TriState)
+{
+    TriState();
+    TriState tristate1("F");
+    TriState tristate2("T");
+    TriState tristate3("True");
+    TriState tristate4("False");
+    TriState tristate5(tristate1);
+    TriState tristate6 =tristate1;
+    TriState tristate7(TriState::EnumState::True);
+
+    EXPECT_EQ(tristate3.Get(),TriState::EnumState::True);
+    tristate3.Set(false);
+    EXPECT_EQ(tristate3.Get(),TriState::EnumState::False);
+    tristate3.Set(TriState::EnumState::Unknown);
+    EXPECT_EQ(tristate3.Get(),TriState::EnumState::Unknown);
+}
+
diff --git b/Tests/core/test_valuerecorder.cpp b/Tests/core/test_valuerecorder.cpp
new file mode 100644
index 0000000..bf991b3
--- /dev/null
+++ b/Tests/core/test_valuerecorder.cpp
@@ -0,0 +1,117 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include "gtest/gtest.h"
+#include "core/core.h"
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+const unsigned int BLOCKSIZE = 20;
+
+class WriterClass : public RecorderType<uint32_t, BLOCKSIZE>::Writer
+{
+    public:
+        WriterClass() = delete;
+
+        WriterClass(string filename)
+            : Writer(filename)
+            , _file(filename)
+        {
+        }
+
+        ~WriterClass()
+        {
+        }
+
+    public:
+        void WriterJob()
+        {
+            uint8_t arr[] = {1,2,3};
+            SetBuffer(arr);
+            Create(_file);
+            Record(10);
+            Time();
+            Source();
+            Value();
+        }
+
+    private:
+        string _file;
+};
+
+class ReaderClass : public RecorderType<uint32_t, BLOCKSIZE>::Reader
+{
+    public:
+        ReaderClass() = delete;
+
+        ReaderClass(string filename)
+            : Reader(filename)
+            , _file(filename)
+        {
+        }
+
+        ReaderClass(const ProxyType<WriterClass>& recorder, const uint32_t id = static_cast<uint32_t>(~0))
+                : Reader(recorder->Source())
+                , _file(recorder->Source())
+        {
+        }
+
+        ~ReaderClass()
+        {
+        }
+
+    public:
+        void ReaderJob()
+        {
+            uint32_t time = 20;
+            Core::Time curTime = Core::Time::Now();
+            curTime.Add(time);
+            Store(curTime.Ticks(), 1);
+            
+            StepForward();
+            StepBack();
+            ClearData();
+            Reader obj1(_file, 1u);
+            EXPECT_FALSE(obj1.Previous());
+            EXPECT_TRUE(obj1.Next());
+
+            EXPECT_EQ(StartId(),1u);;
+            EXPECT_EQ(EndId(),2u);
+            Source();
+        }
+
+    private:
+        string _file;
+};
+
+TEST(test_valuerecorder, test_writer)
+{
+    string filename = "baseRecorder.txt";
+    WriterClass obj1(filename);
+    obj1.Copy(obj1,1);
+    obj1.Copy(obj1,100);
+    obj1.WriterJob();
+    ReaderClass obj2(filename);
+    obj2.ReaderJob();
+    ReaderClass obj3(ProxyType<WriterClass>(obj1));
+}
+
diff --git b/Tests/core/test_weblinkjson.cpp b/Tests/core/test_weblinkjson.cpp
new file mode 100644
index 0000000..2d2e04e
--- /dev/null
+++ b/Tests/core/test_weblinkjson.cpp
@@ -0,0 +1,279 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+#include <websocket/websocket.h>
+
+namespace WPEFramework {
+namespace Tests {
+
+namespace {
+    enum class CommandType {
+        EXECUTESHELL,
+        WIFISETTINGS,
+        FANCONTROL,
+        PLAYERCONTROL
+    };
+
+    class Parameters : public Core::JSON::Container {
+    public:
+        Parameters(const Parameters&) = delete;
+        Parameters& operator=(const Parameters&) = delete;
+
+        Parameters()
+            : Core::JSON::Container()
+            , Speed(0)
+            , Duration(0)
+            , Command()
+            , Settings()
+        {
+            Add(_T("speed"), &Speed);
+            Add(_T("duration"), &Duration);
+            Add(_T("command"), &Command);
+            Add(_T("settings"), &Settings);
+        }
+
+        ~Parameters()
+        {
+        }
+
+    public:
+        Core::JSON::OctSInt16 Speed;
+        Core::JSON::DecUInt16 Duration;
+        Core::JSON::EnumType<CommandType> Command;
+        Core::JSON::ArrayType<Core::JSON::DecUInt16> Settings;
+    };
+
+    class Command : public Core::JSON::Container {
+    public:
+        Command(const Command&) = delete;
+        Command& operator=(const Command&) = delete;
+
+        Command()
+            : Core::JSON::Container()
+            , Identifier(0)
+            , Name()
+            , BaseAddress(0)
+            , TrickFlag(false)
+            , Params()
+        {
+            Add(_T("id"), &Identifier);
+            Add(_T("name"), &Name);
+            Add(_T("baseAddress"), &BaseAddress);
+            Add(_T("trickFlag"), &TrickFlag);
+            Add(_T("parameters"), &Params);
+        }
+
+        ~Command()
+        {
+        }
+
+    public:
+        Core::JSON::DecUInt32 Identifier;
+        Core::JSON::String Name;
+        Core::JSON::HexUInt32 BaseAddress;
+        Core::JSON::Boolean TrickFlag;
+        Parameters Params;
+    };
+
+    typedef Web::JSONBodyType<Command> CommandBody;
+
+    }
+
+    class JSONWebServer : public Web::WebLinkType<Core::SocketStream, Web::Request, Web::Response, WPEFramework::Core::ProxyPoolType<Web::Request>&> {
+    private:
+        typedef Web::WebLinkType<Core::SocketStream, Web::Request, Web::Response, WPEFramework::Core::ProxyPoolType<Web::Request>&> BaseClass;
+
+    public:
+        JSONWebServer() = delete;
+        JSONWebServer(const JSONWebServer& copy) = delete;
+        JSONWebServer& operator=(const JSONWebServer&) = delete;
+
+        JSONWebServer(const SOCKET& connector, const Core::NodeId& remoteId, Core::SocketServerType<JSONWebServer>*)
+            : BaseClass(5, _requestFactory, false, connector, remoteId, 2048, 2048)
+            , _requestFactory(5)
+            , _commandBodyFactory(5)
+        {
+        }
+
+        virtual ~JSONWebServer()
+        {
+            Close(WPEFramework::Core::infinite);
+        }
+
+    public:
+        // Notification of a Partial Request received, time to attach a body..
+        virtual void LinkBody(Core::ProxyType<WPEFramework::Web::Request>& element)
+        {
+            // Time to attach a Command Body
+            element->Body<CommandBody>(_commandBodyFactory.Element());
+        }
+
+        virtual void Received(Core::ProxyType<Web::Request>& request)
+        {
+            EXPECT_EQ(request->Verb, Web::Request::HTTP_GET);
+            EXPECT_EQ(request->MajorVersion, 1);
+            EXPECT_EQ(request->MinorVersion, 1);
+            EXPECT_TRUE(request->HasBody());
+            EXPECT_EQ(request->ContentLength.Value(), 60u);
+
+            Core::ProxyType<Web::Response> response(Core::ProxyType<Web::Response>::Create());
+            response->ErrorCode = 200;
+            response->Body<CommandBody>(request->Body<CommandBody>());
+            Submit(response);
+        }
+
+        virtual void Send(const Core::ProxyType<Web::Response>& response)
+        {
+            EXPECT_EQ(response->ErrorCode, 200);
+            EXPECT_TRUE(response->HasBody());
+        }
+
+        virtual void StateChange()
+        {
+        }
+
+    private:
+        Core::ProxyPoolType<Web::Request> _requestFactory;
+        Core::ProxyPoolType<CommandBody> _commandBodyFactory;
+    };
+
+    class JSONWebClient : public Web::WebLinkType<Core::SocketStream, Web::Response, Web::Request, WPEFramework::Core::ProxyPoolType<Web::Response>&> {
+    private:
+        typedef Web::WebLinkType<Core::SocketStream, Web::Response, Web::Request, WPEFramework::Core::ProxyPoolType<Web::Response>&> BaseClass;
+
+    public:
+        JSONWebClient() = delete;
+        JSONWebClient(const JSONWebClient& copy) = delete;
+        JSONWebClient& operator=(const JSONWebClient&) = delete;
+
+        JSONWebClient(const WPEFramework::Core::NodeId& remoteNode)
+            : BaseClass(5, _responseFactory, false, remoteNode.AnyInterface(), remoteNode, 2048, 208)
+            , _dataPending(false, false)
+            , _responseFactory(5)
+            , _commandBodyFactory(5)
+        {
+        }
+
+        virtual ~JSONWebClient()
+        {
+            Close(WPEFramework::Core::infinite);
+        }
+
+    public:
+        // Notification of a Partial Request received, time to attach a body..
+        virtual void LinkBody(Core::ProxyType<WPEFramework::Web::Response>& element)
+        {
+            // Time to attach a Command Body
+            element->Body<CommandBody>(_commandBodyFactory.Element());
+        }
+
+        virtual void Received(Core::ProxyType<Web::Response>& response)
+        {
+            EXPECT_EQ(response->ErrorCode, 200);
+            EXPECT_STREQ(response->Message.c_str(), "OK");
+            EXPECT_EQ(response->MajorVersion, 1);
+            EXPECT_EQ(response->MinorVersion, 1);
+            EXPECT_TRUE(response->HasBody());
+            EXPECT_EQ(response->ContentLength.Value(), 60u);
+
+            response->Body<CommandBody>()->ToString(_dataReceived);
+            _dataPending.Unlock();
+        }
+
+        virtual void Send(const Core::ProxyType<Web::Request>& request)
+        {
+            EXPECT_EQ(request->Verb, Web::Request::HTTP_GET);
+            EXPECT_TRUE(request->HasBody());
+        }
+
+        virtual void StateChange()
+        {
+        }
+
+        int Wait() const
+        {
+            return _dataPending.Lock();
+        }
+
+        void Retrieve(string& text)
+        {
+            text = _dataReceived;
+            _dataReceived.clear();
+        }
+
+    private:
+        mutable WPEFramework::Core::Event _dataPending;
+        string _dataReceived;
+        Core::ProxyPoolType<Web::Response> _responseFactory;
+        Core::ProxyPoolType<CommandBody> _commandBodyFactory;
+    };
+
+    TEST(WebLink, Json)
+    {
+        std::string connector {"0.0.0.0"};
+        auto lambdaFunc = [connector](IPTestAdministrator & testAdmin) {
+            Core::SocketServerType<JSONWebServer> _webServer(Core::NodeId(connector.c_str(), 12341));
+            _webServer.Open(Core::infinite);
+            testAdmin.Sync("setup server");
+            testAdmin.Sync("client done");
+        };
+
+        static std::function<void (IPTestAdministrator&)> lambdaVar = lambdaFunc;
+
+        IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin ) { lambdaVar(testAdmin); };
+
+        IPTestAdministrator testAdmin(otherSide);
+        testAdmin.Sync("setup server");
+        {
+            JSONWebClient jsonWebConnector(Core::NodeId(connector.c_str(), 12341));
+            Core::ProxyType<Web::Request> jsonRequest(Core::ProxyType<Web::Request>::Create());
+            Core::ProxyType<CommandBody> jsonRequestBody(Core::ProxyType<CommandBody>::Create());
+            jsonRequest->Body<CommandBody>(jsonRequestBody);
+            jsonWebConnector.Open(Core::infinite);
+            while (!jsonWebConnector.IsOpen());
+            jsonRequest->Verb = Web::Request::HTTP_GET;
+            jsonRequestBody->Identifier = 123;
+            jsonRequestBody->Name = _T("TestCase");
+            jsonRequestBody->Params.Speed = 4321;
+            string sent;
+            jsonRequestBody->ToString(sent);
+            jsonWebConnector.Submit(jsonRequest);
+
+            jsonWebConnector.Wait();
+            string received;
+            jsonWebConnector.Retrieve(received);
+            EXPECT_STREQ(received.c_str(), sent.c_str());
+            testAdmin.Sync("client done");
+       }
+       Core::Singleton::Dispose();
+    }
+} // Tests
+
+ENUM_CONVERSION_BEGIN(Tests::CommandType)
+    { Tests::CommandType::EXECUTESHELL, _TXT("ExecuteShell") },
+    { Tests::CommandType::WIFISETTINGS, _TXT("WiFiSettings") },
+    { Tests::CommandType::FANCONTROL, _TXT("FanControl") },
+    { Tests::CommandType::PLAYERCONTROL, _TXT("PlayerControl") },
+ENUM_CONVERSION_END(Tests::CommandType)
+
+} // WPEFramework
diff --git b/Tests/core/test_weblinktext.cpp b/Tests/core/test_weblinktext.cpp
new file mode 100644
index 0000000..873c3dd
--- /dev/null
+++ b/Tests/core/test_weblinktext.cpp
@@ -0,0 +1,196 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+#include <websocket/websocket.h>
+
+namespace WPEFramework {
+namespace Tests {
+
+    class WebServer : public Web::WebLinkType<Core::SocketStream, Web::Request, Web::Response, WPEFramework::Core::ProxyPoolType<Web::Request> > {
+    private:
+        typedef Web::WebLinkType<Core::SocketStream, Web::Request, Web::Response, WPEFramework::Core::ProxyPoolType<Web::Request> > BaseClass;
+
+    public:
+        WebServer() = delete;
+        WebServer(const WebServer& copy) = delete;
+        WebServer& operator=(const WebServer&) = delete;
+
+        WebServer(const SOCKET& connector, const Core::NodeId& remoteId, Core::SocketServerType<WebServer>*)
+            : BaseClass(5, false, connector, remoteId, 2048, 2048)
+        {
+        }
+
+        virtual ~WebServer()
+        {
+            Close(WPEFramework::Core::infinite);
+        }
+
+    public:
+        // Notification of a Partial Request received, time to attach a body..
+        virtual void LinkBody(Core::ProxyType<WPEFramework::Web::Request>& element)
+        {
+            // Time to attach a String Body
+            element->Body(_textBodyFactory.Element());
+        }
+
+        virtual void Received(Core::ProxyType<WPEFramework::Web::Request>& request)
+        {
+            EXPECT_EQ(request->Verb, Web::Request::HTTP_GET);
+            EXPECT_EQ(request->MajorVersion, 1);
+            EXPECT_EQ(request->MinorVersion, 1);
+            EXPECT_TRUE(request->HasBody());
+            EXPECT_EQ(request->ContentLength.Value(), 19u);
+
+            Core::ProxyType<Web::Response> response(Core::ProxyType<Web::Response>::Create());
+            response->ErrorCode = 200;
+            response->Body<Web::TextBody>(request->Body<Web::TextBody>());
+            Submit(response);
+        }
+
+        virtual void Send(const Core::ProxyType<WPEFramework::Web::Response>& response)
+        {
+            EXPECT_EQ(response->ErrorCode, 200);
+            EXPECT_TRUE(response->HasBody());
+        }
+
+        virtual void StateChange()
+        {
+        }
+
+    private:
+        static Core::ProxyPoolType<Web::TextBody> _textBodyFactory;
+    };
+
+    Core::ProxyPoolType<Web::TextBody> WebServer::_textBodyFactory(5);
+
+    class WebClient : public Web::WebLinkType<Core::SocketStream, Web::Response, Web::Request, WPEFramework::Core::ProxyPoolType<Web::Response>&> {
+    private:
+        typedef Web::WebLinkType<Core::SocketStream, Web::Response, Web::Request, WPEFramework::Core::ProxyPoolType<Web::Response>&> BaseClass;
+
+    public:
+        WebClient() = delete;
+        WebClient(const WebClient& copy) = delete;
+        WebClient& operator=(const WebClient&) = delete;
+
+        WebClient(const WPEFramework::Core::NodeId& remoteNode)
+            : BaseClass(5,_responseFactory, false, remoteNode.AnyInterface(), remoteNode, 2048, 208)
+            , _dataPending(false, false)
+        {
+        }
+
+        virtual ~WebClient()
+        {
+            Close(WPEFramework::Core::infinite);
+        }
+
+    public:
+        // Notification of a Partial Request received, time to attach a body..
+        virtual void LinkBody(Core::ProxyType<WPEFramework::Web::Response>& element)
+        {
+            // Time to attach a String Body
+            element->Body(_textBodyFactory.Element());
+        }
+
+        virtual void Received(Core::ProxyType<WPEFramework::Web::Response>& response)
+        {
+            EXPECT_EQ(response->ErrorCode, 200);
+            EXPECT_STREQ(response->Message.c_str(), "OK");
+            EXPECT_EQ(response->MajorVersion, 1);
+            EXPECT_EQ(response->MinorVersion, 1);
+            EXPECT_TRUE(response->HasBody());
+            EXPECT_EQ(response->ContentLength.Value(), 19u);
+
+            _dataReceived = *(response->Body<Web::TextBody>());
+            _dataPending.Unlock();
+        }
+
+        virtual void Send(const Core::ProxyType<WPEFramework::Web::Request>& request)
+        {
+            EXPECT_EQ(request->Verb, Web::Request::HTTP_GET);
+            EXPECT_TRUE(request->HasBody());
+        }
+
+        virtual void StateChange()
+        {
+        }
+
+        int Wait() const
+        {
+            return _dataPending.Lock();
+        }
+
+        void Retrieve(string& text)
+        {
+            text = _dataReceived;
+            _dataReceived.clear();
+        }
+
+    private:
+        mutable WPEFramework::Core::Event _dataPending;
+        string _dataReceived;
+        static Core::ProxyPoolType<Web::Response> _responseFactory;
+        static Core::ProxyPoolType<Web::TextBody> _textBodyFactory;
+    };
+
+    Core::ProxyPoolType<Web::Response> WebClient::_responseFactory(5);
+    Core::ProxyPoolType<Web::TextBody> WebClient::_textBodyFactory(5);
+
+    TEST(WebLink, Text)
+    {
+        std::string connector {"127.0.0.1"};
+        auto lambdaFunc = [connector](IPTestAdministrator & testAdmin) {
+            Core::SocketServerType<WebServer> _webServer(Core::NodeId(connector.c_str(), 12343));
+            _webServer.Open(Core::infinite);
+            testAdmin.Sync("setup server");
+            testAdmin.Sync("client done");
+        };
+
+        static std::function<void (IPTestAdministrator&)> lambdaVar = lambdaFunc;
+
+        IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin ) { lambdaVar(testAdmin); };
+
+        IPTestAdministrator testAdmin(otherSide);
+        testAdmin.Sync("setup server");
+        {
+            WebClient webConnector(Core::NodeId(connector.c_str(), 12343));
+            Core::ProxyType<Web::Request> webRequest(Core::ProxyType<Web::Request>::Create());
+            Core::ProxyType<Web::TextBody> webRequestBody(Core::ProxyType<Web::TextBody>::Create());
+            webRequest->Body<Web::TextBody>(webRequestBody);
+            webConnector.Open(Core::infinite);
+            while (!webConnector.IsOpen());
+            webRequest->Verb = Web::Request::HTTP_GET;
+            string sent = "Just a body to send";
+            *webRequestBody = sent;
+            webConnector.Submit(webRequest);
+
+            webConnector.Wait();
+            string received;
+            webConnector.Retrieve(received);
+            EXPECT_STREQ(received.c_str(), sent.c_str());
+            testAdmin.Sync("client done");
+        }
+        Core::Singleton::Dispose();
+    }
+
+} // Tests
+} // WPEFramework
diff --git b/Tests/core/test_websocketjson.cpp b/Tests/core/test_websocketjson.cpp
new file mode 100644
index 0000000..2c2ff2e
--- /dev/null
+++ b/Tests/core/test_websocketjson.cpp
@@ -0,0 +1,253 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+#include <websocket/websocket.h>
+#include <condition_variable>
+#include <mutex>
+
+namespace WPEFramework {
+namespace Tests {
+
+    class Message : public Core::JSON::Container {
+    public:
+        Message(const Message&) = delete;
+	    Message& operator= (const Message&) = delete;
+
+	    Message()
+            : Core::JSON::Container()
+            , EventType()
+            , Event()
+        {
+            Add(_T("eventType"), &EventType);
+            Add(_T("event"), &Event);
+        }
+
+        ~Message()
+        {
+        }
+
+    public:
+	    Core::JSON::String EventType;
+	    Core::JSON::String Event;
+    };
+
+    class Factory : public Core::ProxyPoolType<Message> {
+    public:
+	    Factory() = delete;
+	    Factory(const Factory&) = delete;
+	    Factory& operator= (const Factory&) = delete;
+
+	    Factory(const uint32_t number) : Core::ProxyPoolType<Message>(number)
+        {
+	    }
+
+	    virtual ~Factory()
+        {
+	    }
+
+    public:
+	    Core::ProxyType<Core::JSON::IElement> Element(const string&)
+        {
+		    return (Core::proxy_cast<Core::JSON::IElement>(Core::ProxyPoolType<Message>::Element()));
+	    }
+    };
+
+    template<typename INTERFACE>
+    class JsonSocketServer : public Core::StreamJSONType< Web::WebSocketServerType<Core::SocketStream>, Factory&, INTERFACE> {
+    private:
+	    typedef Core::StreamJSONType< Web::WebSocketServerType<Core::SocketStream>, Factory&, INTERFACE> BaseClass;
+
+    public:
+        JsonSocketServer() = delete;
+        JsonSocketServer(const JsonSocketServer&) = delete;
+	    JsonSocketServer& operator=(const JsonSocketServer&) = delete;
+
+        JsonSocketServer(const SOCKET& socket, const Core::NodeId& remoteNode, Core::SocketServerType<JsonSocketServer<INTERFACE>>*)
+            : BaseClass(2, _objectFactory, false, false, false, socket, remoteNode, 512, 512)
+		    , _objectFactory(1)
+        {
+	    }
+
+        virtual ~JsonSocketServer()
+        {
+        }
+
+    public:
+	    virtual bool IsIdle() const
+        {
+            return (true);
+        }
+
+	    virtual void StateChange()
+        {
+		    if (this->IsOpen()) {
+                std::unique_lock<std::mutex> lk(_mutex);
+                _done = true;
+                _cv.notify_one();
+            }
+        }
+
+        bool IsAttached() const
+        {
+            return (this->IsOpen());
+        }
+
+        virtual void Received(Core::ProxyType<Core::JSON::IElement>& jsonObject)
+        {
+            this->Submit(jsonObject);
+        }
+
+        virtual void Send(Core::ProxyType<Core::JSON::IElement>& jsonObject)
+        {
+	    }
+
+        static bool GetState()
+        {
+            return _done;
+        }
+
+    private:
+	    Factory _objectFactory;
+        static bool _done;
+
+    public:
+        static std::mutex _mutex;
+        static std::condition_variable _cv;
+    };
+
+    template<typename INTERFACE>
+    std::mutex JsonSocketServer<INTERFACE>::_mutex;
+    template<typename INTERFACE>
+    std::condition_variable JsonSocketServer<INTERFACE>::_cv;
+    template<typename INTERFACE>
+    bool JsonSocketServer<INTERFACE>::_done = false;
+
+    template<typename INTERFACE>
+    class JsonSocketClient : public Core::StreamJSONType<Web::WebSocketClientType<Core::SocketStream>, Factory&, INTERFACE> {
+    private:
+		typedef Core::StreamJSONType<Web::WebSocketClientType<Core::SocketStream>, Factory&, INTERFACE> BaseClass;
+
+    public:
+        JsonSocketClient() = delete;
+        JsonSocketClient(const JsonSocketClient&) = delete;
+        JsonSocketClient& operator=(const JsonSocketClient&) = delete;
+
+        JsonSocketClient(const Core::NodeId& remoteNode)
+		    : BaseClass(5, _objectFactory, _T(""), _T(""), _T(""), _T(""), false, true, false, remoteNode.AnyInterface(), remoteNode, 256, 256)
+            , _objectFactory(2)
+            , _dataPending(false, false)
+        {
+        }
+
+        virtual ~JsonSocketClient()
+        {
+        }
+
+    public:
+	    virtual void Received(Core::ProxyType<Core::JSON::IElement>& jsonObject)
+	    {
+		    string textElement;
+		    jsonObject->ToString(textElement);
+            _dataReceived = textElement;
+            _dataPending.Unlock();
+        }
+
+        virtual void Send(Core::ProxyType<Core::JSON::IElement>& jsonObject)
+	    {
+        }
+
+        virtual void StateChange()
+	    {
+        }
+
+        virtual bool IsIdle() const
+	    {
+		    return (true);
+        }
+
+        Core::ProxyType<Core::JSON::IElement> Element()
+        {
+            return _objectFactory.Element("");
+        }
+
+        int Wait() const
+        {
+            return _dataPending.Lock();
+        }
+
+        void Retrieve(string& text)
+        {
+            text = _dataReceived;
+            _dataReceived.clear();
+        }
+
+    private:
+        Factory _objectFactory;
+        string _dataReceived;
+        mutable Core::Event _dataPending;
+    };
+
+    TEST(WebSocket, Json)
+    {
+        std::string connector {"/tmp/wpewebsocketjson0"};
+        auto lambdaFunc = [connector](IPTestAdministrator & testAdmin) {
+            Core::SocketServerType<JsonSocketServer<Core::JSON::IElement>> jsonWebSocketServer(Core::NodeId(connector.c_str()));
+            jsonWebSocketServer.Open(Core::infinite);
+            testAdmin.Sync("setup server");
+
+            std::unique_lock<std::mutex> lk(JsonSocketServer<Core::JSON::IElement>::_mutex);
+            while (!JsonSocketServer<Core::JSON::IElement>::GetState()) {
+                JsonSocketServer<Core::JSON::IElement>::_cv.wait(lk);
+            }
+            testAdmin.Sync("server open");
+            testAdmin.Sync("client done");
+        };
+
+        static std::function<void (IPTestAdministrator&)> lambdaVar = lambdaFunc;
+
+        IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin ) { lambdaVar(testAdmin); };
+
+        IPTestAdministrator testAdmin(otherSide);
+        testAdmin.Sync("setup server");
+        {
+            Core::ProxyType<Message> sendObject = Core::ProxyType<Message>::Create();
+            sendObject->EventType = _T("Test");
+            sendObject->Event = _T("TestSend");
+            std::string sendString;
+            sendObject->ToString(sendString);
+
+            JsonSocketClient<Core::JSON::IElement> jsonWebSocketClient(Core::NodeId(connector.c_str()));
+            jsonWebSocketClient.Open(Core::infinite);
+            testAdmin.Sync("server open");
+            jsonWebSocketClient.Submit(Core::proxy_cast<Core::JSON::IElement>(sendObject));
+            jsonWebSocketClient.Wait();
+            string received;
+            jsonWebSocketClient.Retrieve(received);
+            EXPECT_STREQ(sendString.c_str(), received.c_str());
+            jsonWebSocketClient.Close(Core::infinite);
+            testAdmin.Sync("client done");
+        }
+        Core::Singleton::Dispose();
+    }
+} // Tests
+} // WPEFramework
diff --git b/Tests/core/test_websockettext.cpp b/Tests/core/test_websockettext.cpp
new file mode 100644
index 0000000..be14db7
--- /dev/null
+++ b/Tests/core/test_websockettext.cpp
@@ -0,0 +1,173 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+#include <websocket/websocket.h>
+#include <condition_variable>
+#include <mutex>
+
+namespace WPEFramework {
+namespace Tests {
+
+    class TextSocketServer : public Core::StreamTextType<Web::WebSocketServerType<Core::SocketStream>, Core::TerminatorCarriageReturn> {
+    private:
+        typedef Core::StreamTextType<Web::WebSocketServerType<Core::SocketStream>, Core::TerminatorCarriageReturn> BaseClass;
+
+    public:
+        TextSocketServer() = delete;
+	    TextSocketServer(const TextSocketServer&) = delete;
+	    TextSocketServer& operator=(const TextSocketServer&) = delete;
+
+        TextSocketServer(const SOCKET& socket, const WPEFramework::Core::NodeId& remoteNode, WPEFramework::Core::SocketServerType<TextSocketServer>*)
+            : BaseClass(false, true, false, socket, remoteNode, 1024, 1024)
+        {
+        }
+
+        virtual ~TextSocketServer()
+        {
+        }
+
+    public:
+	    virtual void StateChange()
+        {
+		    if (IsOpen()) {
+                std::unique_lock<std::mutex> lk(_mutex);
+                _done = true;
+                _cv.notify_one();
+            }
+        }
+
+        virtual void Received(string& text)
+        {
+            Submit(text);
+        }
+
+        virtual void Send(const string& text)
+        {
+        }
+
+        static bool GetState()
+        {
+            return _done;
+        }
+
+    private:
+        static bool _done;
+
+    public:
+        static std::mutex _mutex;
+        static std::condition_variable _cv;
+    };
+
+    bool TextSocketServer::_done = false;
+    std::mutex TextSocketServer::_mutex;
+    std::condition_variable TextSocketServer::_cv;
+
+    class TextSocketClient : public Core::StreamTextType<Web::WebSocketClientType<Core::SocketStream>, Core::TerminatorCarriageReturn> {
+    private:
+		typedef Core::StreamTextType<Web::WebSocketClientType<Core::SocketStream>, Core::TerminatorCarriageReturn> BaseClass;
+
+    public:
+        TextSocketClient() = delete;
+	    TextSocketClient(const TextSocketClient&) = delete;
+        TextSocketClient& operator=(const TextSocketClient&) = delete;
+
+        TextSocketClient(const Core::NodeId& remoteNode)
+            : BaseClass(_T("/"), _T("echo"), "", "", false, true, false, remoteNode.AnyInterface(), remoteNode, 1024, 1024)
+            , _dataPending(false, false)
+        {
+        }
+
+	    virtual ~TextSocketClient()
+        {
+	    }
+
+    public:
+	    virtual void Received(string& text)
+	    {
+            _dataReceived = text;
+            _dataPending.Unlock();
+	    }
+
+        virtual void Send(const string& text)
+        {
+        }
+
+	    virtual void StateChange()
+        {
+        }
+
+        int Wait() const
+        {
+            return _dataPending.Lock();
+        }
+
+        void Retrieve(string& text)
+        {
+            text = _dataReceived;
+            _dataReceived.clear();
+        }
+
+    private:
+        string _dataReceived;
+        mutable WPEFramework::Core::Event _dataPending;
+    };
+
+    TEST(WebSocket, Text)
+    {
+        std::string connector {"/tmp/wpewebsockettext0"};
+        auto lambdaFunc = [connector](IPTestAdministrator & testAdmin) {
+            Core::SocketServerType<TextSocketServer> textWebSocketServer(Core::NodeId(connector.c_str()));
+            textWebSocketServer.Open(Core::infinite);
+            testAdmin.Sync("setup server");
+            std::unique_lock<std::mutex> lk(TextSocketServer::_mutex);
+            while (!TextSocketServer::GetState()) {
+                TextSocketServer::_cv.wait(lk);
+            }
+
+            testAdmin.Sync("server open");
+            testAdmin.Sync("client done");
+        };
+
+        static std::function<void (IPTestAdministrator&)> lambdaVar = lambdaFunc;
+
+        IPTestAdministrator::OtherSideMain otherSide = [](IPTestAdministrator& testAdmin ) { lambdaVar(testAdmin); };
+
+        IPTestAdministrator testAdmin(otherSide);
+        testAdmin.Sync("setup server");
+        {
+            TextSocketClient textWebSocketClient(Core::NodeId(connector.c_str()));
+            textWebSocketClient.Open(Core::infinite);
+            testAdmin.Sync("server open");
+            string sentString = "Test String";
+            textWebSocketClient.Submit(sentString);
+            textWebSocketClient.Wait();
+            string received;
+            textWebSocketClient.Retrieve(received);
+            EXPECT_STREQ(sentString.c_str(), received.c_str());
+            textWebSocketClient.Close(Core::infinite);
+            testAdmin.Sync("client done");
+        }
+        Core::Singleton::Dispose();
+    }
+} // Tests
+} // WPEFramework
diff --git b/Tests/core/test_workerpool.cpp b/Tests/core/test_workerpool.cpp
new file mode 100644
index 0000000..efb41ff
--- /dev/null
+++ b/Tests/core/test_workerpool.cpp
@@ -0,0 +1,137 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/core.h>
+#include <thread>
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+class WorkerPoolImplementation : public Core::WorkerPool {
+public:
+    WorkerPoolImplementation() = delete;
+    WorkerPoolImplementation(const WorkerPoolImplementation&) = delete;
+    WorkerPoolImplementation& operator=(const WorkerPoolImplementation&) = delete;
+
+    WorkerPoolImplementation(const uint8_t threads, const uint32_t stackSize, const uint32_t queueSize)
+        : WorkerPool(threads, stackSize, queueSize)
+    {
+    }
+
+    ~WorkerPoolImplementation()
+    {
+        // Diable the queue so the minions can stop, even if they are processing and waiting for work..
+        Stop();
+    }
+
+public:
+    void Run()
+    {
+        Core::WorkerPool::Run();
+        Core::WorkerPool::Join();
+    }
+
+    void Stop()
+    {
+        Core::WorkerPool::Stop();
+    }
+};
+
+Core::ProxyType<WorkerPoolImplementation> workerpool = Core::ProxyType<WorkerPoolImplementation>::Create(2, Core::Thread::DefaultStackSize(), 8);
+
+class WorkerThreadClass : public Core::Thread {
+public:
+    WorkerThreadClass() = delete;
+    WorkerThreadClass(const WorkerThreadClass&) = delete;
+    WorkerThreadClass& operator=(const WorkerThreadClass&) = delete;
+
+    WorkerThreadClass(std::thread::id parentworkerId)
+        : Core::Thread(Core::Thread::DefaultStackSize(), _T("Test"))
+        , _parentworkerId(parentworkerId)
+        , _threadDone(false)
+    {
+    }
+
+    virtual ~WorkerThreadClass()
+    {
+    }
+
+    virtual uint32_t Worker() override
+    {
+        while (IsRunning() && (!_threadDone)) {
+            EXPECT_TRUE(_parentworkerId != std::this_thread::get_id());
+            ::SleepMs(250);
+            _threadDone = true;
+            workerpool->Stop();
+        }
+        return (Core::infinite);
+    }
+
+private:
+    std::thread::id _parentworkerId;
+    volatile bool _threadDone;
+};
+
+class WorkerJob : public Core::IDispatch {
+public:
+    WorkerJob(const WorkerJob&) = delete;
+    WorkerJob& operator=(const WorkerJob&) = delete;
+
+    WorkerJob()
+    {
+    }
+
+    ~WorkerJob()
+    {
+    }
+
+    virtual void Dispatch() override
+    {
+        EXPECT_NE(_parentJobId, std::this_thread::get_id());
+    }
+
+public:
+    static std::thread::id _parentJobId;
+};
+
+std::thread::id WorkerJob::_parentJobId;
+
+TEST(test_workerpool, simple_workerpool)
+{
+    WorkerThreadClass object(std::this_thread::get_id());
+    object.Run();
+
+    WorkerPoolImplementation workerpool_impl(2,Core::Thread::DefaultStackSize(),8);
+    Core::WorkerPool::Assign(&workerpool_impl);
+    workerpool->Run();
+    workerpool->Id(0);
+    EXPECT_EQ(workerpool->Id(1),0u);
+    workerpool->Snapshot();
+    Core::ProxyType<Core::IDispatch> job(Core::ProxyType<WorkerJob>::Create());
+    workerpool->Submit(job);
+    workerpool->Schedule(Core::infinite, job);
+    workerpool->Revoke(job);
+    workerpool->Instance();
+    EXPECT_TRUE(workerpool->IsAvailable());
+    workerpool->Stop();
+    object.Stop();
+}
diff --git b/Tests/core/test_xgetopt.cpp b/Tests/core/test_xgetopt.cpp
new file mode 100644
index 0000000..3f2807e
--- /dev/null
+++ b/Tests/core/test_xgetopt.cpp
@@ -0,0 +1,70 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "../IPTestAdministrator.h"
+
+#include <gtest/gtest.h>
+#include <core/XGetopt.h>
+
+int argumentCount = 3;
+char* arguments[]= {(char*)"-c", (char*)"-h", (char*)"-b"};
+
+using namespace WPEFramework;
+using namespace WPEFramework::Core;
+
+class ConsoleOptions : public Core::Options {
+    public:
+        ConsoleOptions() = delete;
+
+        ConsoleOptions(int argumentCount, TCHAR* arguments[])
+            : Core::Options(argumentCount, arguments, _T("chb"))
+        {
+            Parse();
+        }
+
+        ~ConsoleOptions()
+        {
+        }
+
+     private:
+        virtual void Option(const TCHAR option, const TCHAR* argument)
+        {
+            switch (option) {
+            case 'c':
+                EXPECT_EQ(option,'c');
+                break;
+#ifndef __WIN32__
+            case 'b':
+                EXPECT_EQ(option,'b');
+                break;
+#endif
+            case 'h':
+                EXPECT_EQ(option,'h');
+                break;
+            default:
+                printf("default\n");
+                break;
+            }
+        }
+};
+
+TEST(test_xgetopt, simple_xgetopt)
+{
+    ConsoleOptions consoleOptions(argumentCount,arguments);
+}
